\section{Остовные деревья}

% \subsection{Практика}
% \begin{enumerate}
% % Добавить что-то про критерий Тарьяна?
%   \item
%     Пусть дан взвешенный связный неорграф $G = \langle V, E \rangle$ с выделенной вершиной $s$.
%     Все веса положительны и различны. Могут ли какое-либо минимальное покрывающее
%     дерево в $G$ и какое-либо дерево кратчайших путей из $s$ не иметь ни одного общего ребра? Если да, приведите пример. Если нет, докажите, что такого не может быть.

%   \item
%     В стране $n$ аэропортов. Самолет может сделать перелет 
%     из аэропорта $i$ в аэропорт $j$, израсходовав $w_{ij}$ горючего.
%     При этом $w_{ij} = w_{ji}$, и $w_{ii} = 0$.
%     Требуется найти минимальный размер бака, позволяющий добраться
%     самолету из любого города в любой, возможно с дозаправками.
%     Решить за $\O(n^2)$.

%   \item
%     Рассмотрим следующий алгоритм поиска минимального покрывающего
%     дерева (алгоритм Борувки):
%     \begin{itemize}
%     \item Пока в графе больше одной вершины:
%       \begin{itemize}
%       \item Для каждой вершины найдем самое легкое инцидентное ей ребро и добавим его
%         в множество $S$ (одно и то же ребро может быть выбрано дважды).
%       \item Добавим все ребра из множества $S$ в ответ.
%       \item Стянем граф по ребрам из $S$.
%       \end{itemize}
%     \end{itemize}
%     Докажите, что такой алгоритм найдет минимальное покрывающее дерево в
%     случае, если веса всех ребер в графе различны, при этом время
%     работы будет $\O(E \log V)$.

%     Придумайте, как модифицировать алгоритм, если возможны равные веса.

%   \item
%     \begin{enumerate}
%       \item Постройте пример для алгоритма Борувки, на котором он делает $\Theta(\log n)$ фаз.
%       \item Постройте пример для алгоритма Борувки, на котором он делает $\Theta(1)$ фаз.
%     \end{enumerate}

%   \item
%     Найти во взвешенном неорграфе такой цикл, что максимальный вес ребра этого цикла
%     минимален. $\O((V+E)\log{E})$.

%   \item
%     Дан взвешенный связный неориентированный граф $G = \langle V, E \rangle$ и некоторое минимальное остовное дерево на нём.
%     Пусть для некоторого ребра $e \in E$ изменился вес. По графу, остовному дереву, ребру $e$ и его новому весу найдите новое минимальное остовное дерево за $\O(V + E)$.

%   \item
%     Пусть даны взвешенный неорграф с неединственным минимальным остовным деревом и какой-то
%     из его минимальных остовов. Найдите минимальный остов графа, отличный от данного. $\O(E \log V)$.

%   \item
%     Пусть все ребра графа имеют различный вес. Докажите, что минимальное покрывающее
%     дерево единственно.

%   \item
%     Проверить, что минимальное по весу остовное дерево единственно. $\O(E \log V)$.

%   \item
%     Найдите за полиномиальное время второе по весу остовное дерево в неографе.

%   \item
%     Дан взвешенный орграф, постройте ориентированное к корню остовное дерево с корнем в
%     вершине $1$ минимального веса.

% \end{enumerate}

% \newpage

\subsection{Домашнее задание}
\begin{enumerate}
  \item
    Докажите, что максимальный вес ребра на пути между парой вершин в минимальном остове графа $G$
    не зависит от выбора конкретного минимального остова $G$.
    
  \item 
    По неориентированному графу и его минимальному остовному дереву найдите второе остовное
    дерево (т.е. самое легкое остовное дерево из несовпадающих с данным в условии минимальным;
    деревья сравниваются как множества ребер) за время $\O(V^2 + E)$.

  \item
    Пусть дан связный взвешенный неорграф, будем рассматривать его ребра в порядке невозрастания веса и
    удалять текущее ребро, если связность графа при этом не нарушается. Докажите, что этот алгоритм
    находит минимальный остов, или придумайте контрпример.

    \begin{solution}
      Докажем, что данный \href{https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F}{алгоритм} находит минимальный остов. Для этого сначала докажем, что алгоритм находит остовное дерево, а потом докажем, что оно минимально.

      После выполнения алгоритма получившийся подграф связен, потому что алгоритм удаляет ребра только в тех случаях, когда связность не нарушается. После выполнения алгоритма получившийся подграф не имеет циклов, потому что алгоритм, проходящий по циклу должен найти максимальное по весу ребро в нем и удалить его. Вывод: алгоритм на выходе выдает остовное дерево исходного графа.

      Докажем по индукции, что верно следующее утверждение P: после выполнения, алгоритм оставляет некоторое подмножество ребер F, которое является минимальным остовом исходного графа.
      
      Поскольку взвешенный связный граф всегда имеет минимальное остовное дерево и поскольку F содержит все рёбра графа, то это минимальное остовное дерево должно быть подмножеством F.
      
      Предположим, что утверждение P верно для некоторого промежуточного множества рёбер F и пусть T будет минимальным остовным деревом, которое содержится в F. Покажем, что после удаления ребра e в алгоритме существует некоторое остовное дерево T', которое является подмножеством F.
      \begin{itemize}
        \item если следующее удалённое ребро e не принадлежит T, то T=T' является подмножеством F и утверждение P выполняется.
        \item если ребро e принадлежит T: сначала заметим, что алгоритм удаляет только рёбра, которые не вызывают разрушения связности F, поэтому удаление ребра e не приводит к несвязности графа F, но удаление e приводит к несвязности дерева T (поскольку входит в T). Предположим, что e разбивает T на подграфы t1 и t2. Поскольку весь граф после удаления e остаётся связным, должен существовать путь между t1 и t2 (отличный от e), так что должен существовать цикл C в F (до удаления e). Теперь мы должны иметь другое ребро в этом цикле (пусть это будет f), которое не принадлежит T, но входит в F (поскольку если все рёбра цикла были бы в дереве T, оно не было бы деревом). Мы теперь утверждаем, что T' = T — e + f является минимальным остовным деревом, которое является подмножеством F.
        \item Докажем, что T' является остовным деревом. Известно, что удаление ребра в дереве и добавление другого ребра не создаёт цикла и мы получаем другое дерево с теми же вершинами. Поскольку T было остовным деревом, T' должно быть также остовным деревом. Тогда добавление «f» не создаёт какого-либо цикла, поскольку удаляется «e» (дерево T содержит все вершины графа).
        \item Теперь докажем, что T' является минимальным остовным деревом. У нас есть три случая для рёбер «e» и «f», определяемых функцией веса wt.
        \begin{itemize}
          \item Случай wt(f) < wt(e), что невозможно, поскольку из этого следует, что вес дерева T' строго меньше T. Поскольку T является минимальным остовным деревом, это просто невозможно.
          \item Случай wt(f) > wt(e), что невозможно, поскольку когда мы проходим по рёбрам в убывающем порядке весов, мы должны видеть «f» первым. Поскольку мы имеем C, то удаление «f» не приводи к несвязности в F, так что алгоритм должен был бы удалить ребро из F ранее. То есть, «f» не принадлежит F, что невозможно (мы доказали принадлежность f на шаге 4).
          \item Случай wt(f) = wt(e), так что T' является минимальным остовным деревом, так что утверждение P выполняется.
        \end{itemize}
      \end{itemize}
      
      Таким образом, утверждение P выполняется после завершения цикла. Было доказано, что в конце F становится остовным деревом, которое имеет минимальное остовное дерево в качестве подмножества, так что F само должно быть минимальным остовным деревом.
    \end{solution}
    
  \item
     Есть $n$ городов. Можно соединить два города $i$ и $j$ дорогой, потратив $A \cdot len(i, j)$
     денег, где $len(i, j)$ -- длина дороги (длины заданы матрицей), а можно построить аэропорт,
     потратив $B$ денег. $A, B > 0$. Нужно за минимальное число денег соединить города
     (чтобы от каждого до каждого можно было добраться с помощью дорог и самолетов). $\O(n^2)$.

  \item
    Вам нужно передать с одного компьютера на другой $n$ файлов. Каждый файл -- битовый вектор
    размера $m$. Файл можно передать либо просто как последовательность битов, либо как $diff$
    с другим файлом, уже пересланным ранее. В первом случае надо будет передать $m$ бит, во
    втором - $A+B*d$ бит, где $d$ - число различающихся битов, $A$ и $B$ -- некоторые
    константы. Найти минимальное число битов, которое нужно передать, чтобы отправить все
    файлы с одного компьютера на другой. $\O(mn^2)$.

% \subsection*{Дополнительные задачи}
%   \item
%     {\bf Второе остовное дерево lvl. 2} \\
%  	Дан взвешенный связный неорграф $G$, вес его минимального остова равен $w$. Найдите за полиномиальное время
%  	минимальный по весу среди таких остовов $G$, вес которых строго превосходит $w$.
	
%   \item
%     Дан взвешенный граф с положительными весами, в вершинах его стоят
%     числа. Требуется доставить все числа в вершину $0$. За то, чтобы
%     провести число $a$ по ребру веса $w$ надо заплатить сумму
%     $aw$. Если два числа находятся в одной вершине, то их можно слить,
%     заменив на максимум.  Постройте алгоритм доставки, дающий
%     константное приближение к оптимальному ответу за полиномиальное
%     время.
\end{enumerate}

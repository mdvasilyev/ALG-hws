\section{Добор баллов}

\subsection{Линейные алгоритмы HW2}
\begin{enumerate}
    
    \item[8.] % https://peltorator.ru/posts/stack-of-records/
        Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{Z}$. За {\bf один проход}
        по последовательности и $\O(n)$ времени найдите для каждого элемента ближайший строго
        меньший слева и ближайший меньший либо равный справа. Кроме самой последовательности
        можно использовать два write-only массива в которые надо записать ответ, один стек
        размера порядка $n$ и $\O(1)$ дополнительной памяти.

    \begin{solution}
        Создадим два массива длины $n$: $l$ и $r$. Элементы $l$ -- индексы ближайших строго меньших элементов, находящихся левее текущего. Элементы $r$ -- индексы ближайших меньших либо равных элементов, находящихся правее текущего. При инициализации заполним оба массива $-1$-ми, которые будут индикаторами того, что у конкретного элемента нет левее (или правее) соседа с меньшим (или меньшим либо равным) значением. Заведем стек, который понадобится для заполнения массивов $l, r$ при проходе по исходному массиву $a$. Алгоритм:

        for i = 0..n-1:
        
        $\>$ $\>$ while !stack.empty() and a[i] <= a[stack.top()]:

        $\>$ $\>$ $\>$ $\>$ r[stack.top()] = i
       
        $\>$ $\>$ $\>$ $\>$ stack.pop()
        
        $\>$ $\>$ if !stack.empty():

        $\>$ $\>$ $\>$ $\>$ l[i] = stack.top()

        $\>$ $\>$ stack.push(i)

        На первой итерации складываем индекс первого элемента в стек, дальше итерируемся по массиву и проверяем меньше либо равен текущий элемент, чем тот, который лежит на вершине стека. Делаем это, пока стек не опустеет либо не будет соблюдаться условие. Если текущий меньше, чем тот, который на вершине стека, то записываем соответствующий индекс в $r$ и снимаем элемент со стека. После этого, если стек непустой, то в $l$ для текущего элемента записываем индекс верхнего элемента стека.

        Корректность:
        Массив $r$ заполняется в том случае, когда текущий элемент меньше либо равен элемента на вершине стека, а элемент на вершине стека -- ближайший к текущему, поэтому $r$ заполняется корректно. Массив $l$ заполняется в том случае, когда текущий элемент строго больше, чем элемент на вершине стека $\rightarrow$ меняем местами и получаем строго меньше, что уже удовлетворяет требованию $l$.

        Асимптотика:
        Цикл по $n$ элементам, на каждой итерации все операции работают за константу. Цикл while, за все $n$ итераций внешнего цикло for, сработает не более $n$ раз. Поэтому в сумме алгоритм работает за $\O(n)$.

    \end{solution}

    \item[9.] % https://e-maxx.ru/algo/maximum_zero_submatrix
        Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
        подпрямоугольник, состоящий только из нулей за $\O(n^2)$.
    
    \begin{solution}
        Пусть исходная матрица задается с помощью $a[i][j]$. Построим матрицу $b[i][j]$, которая изначально заполнена $-1$. $b[i][j]$ -- это индекс ближайшей сверху единицы для $a[i][j]$. $b[i][j]$ можно посчитать, двигаясь по матрице сверху вниз: пусть мы стоит в $i$-ой строке, и известно значение для предыдущей строки. Тогда достаточно скопировать эти значения в $b[i][j]$ для текущей строки, изменив только те элементы, в которых в матрице стоят единицы.

        Искомая нулевая подматрица ограничена со всех сторон единичками или границами. Чтобы определить максимальную нулевую подматрицу будем перебирать номер $i$ нижней строки нулевой подматрицы, затем переберём, в каком столбце $j$ мы будем упирать вверх нулевую подматрицу. Пользуясь значением $b[i][j]$, мы сразу получаем номер верхней строки нулевой подматрицы. Но, чтобы подматрица была максимальной, нужно максимально расширить левую и правую границы. То есть нужно найти такой индекс $k_l$, для которого $b[i][k_l] > b[i][j]$, и при этом $k_l$ ближайший слева для индекса $j$. Тогда $k_l+1$ будет левой границей искомой подматрицы. Для правой границы нужно определить индекс $k_r$ -- ближайший справа от $j$ индекс для которого выполняется условие $b[i][k_r] > b[i][j]$.
        
        Значения $k_l$ и $k_r$ можно записывать в $b[i][j]$ для каждой клетки. Чтобы найти $k_l$ будем просматривать все столбцы $j$ слева направо, и заведём стек, как при решении предыдущей задачи. В стеке будут лежать только те столбцы, в которых значение матрицы $d$ строго больше $d[i][j]$. При переходе от столбца $j$ к следующему нужно обновить содержимое этого стека. Сначала в стек нужно положить столбец $j$, а затем, пока на вершине стека лежит неподходящий элемент, у которого значение $b \le b[i][j+1]$ — доставать этот элемент. $k_r$ ищется аналогично, только столбцы нужно будет просматривать справа налево. В конце пробегаемся по обновленной $b[i][j]$ и для каждой $i$ площадь подматрицы.
        
        Асимптотика:
        Вспомогательную матрицу $b[i][j]$ считаем за $\O(n^2)$. Для каждой строки за линию два раза считаем $k_l$ и $k_r$ (как в предыдущей задаче). Определяем ответ, пробегаясь по матрице за $\O(n^2)$. Суммарно $\O(n^2)$.

    \end{solution}
\end{enumerate}

\subsection{Разделяй и властвуй HW3}
\begin{enumerate}
    \item[8.] Дан массив из $2n$ различных чисел. Найдите минимальное и максимальное за $3n - 2$ сравнения и докажите, что это точная нижняя оценка, то есть меньшего количества сравнений может не хватить.
    \begin{solution}
        Данную задачу можно решить, если удобно разбить исходный массив длины $2n$ на два массива одинаковой длины так, чтобы было достоверно известно, что в одном из них лежит минимальное число, а в другом максимальное. Сделать это можно следующим образом: разобьем исходный массив на пары и проведем сравнения элементов в рамках каждой пары. Если элемент оказывается меньше своего соседа, то записываем его в первый массив, а соседа во второй, в противном случае -- наоборот. В итоге за $n$ сравнений мы разбили исходный массив на два: в первом из них лежит минимальный элемент (потому что в первый массив мы всегда записывали элементы, которые были меньше своих соседей по парам), а во втором -- максимальный. Осталость теперь в первом массиве найти минимум за $n-1$ сравнение, и во втором -- максимум за $n-1$ сравнение. Просто проходим по массиву и сравниваем очередной элемент с текущим минимумов/максимумом.

        Алгоритм, поиска минимума или максимума -- по сути процесс сокращения множества кандидатов на минимум и максимум. Если нам дано множество из $2n$ элементов, то кандидатов на максимум тоже $2n$, ровно как и кандидатов на минимум, потому что никакой информации про исходное множество мы не имеем. При сравнениях мы получаем информацию, которая сокращает эти множества. А именно, если мы сравниваем два елемента $a$ и $b$ (не ограничивая общности, пусть $a<b$), которые не сравнивались до этого, то множество минимумов сократится на 1 (потому что $b$ уже точно не может быть минимумом, раз $b$ не меньше $a$), также как и множество максимумов сократится на 1 (потому что $a$ уже точно не может быть максимумов, раз $a$ меньше $b$). Если мы сравниваем какое-то новое число (про него ничего не знаем) с числом, про которое мы уже что-то знаем, то в таком случае сократится только одно из множеств на 1, потому число, про которое что-то знаем, уже удалено из другого множества.

        Допустим, что какой-то алгоритм находит минимум и максимум в массиве из $2n$ элементов за число сравнений, меньшее, чем $3n-2$. Для этого он сделает $x$ "уменьшений множеств на 2" и $y$ "уменьшений множеств на 1. Соответственно, алгоритм удалит $2x+y$ элементов из исходных множеств, чтобы остались всего 2 -- минимум и максимум. Составим систему:
        \begin{equation}
            \begin{cases}
                x+y<3n-2 \\
                4n-(2x+y)=2
            \end{cases}
        \end{equation} $\Rightarrow$
        \begin{equation}
            \begin{cases}
                y=4n-2x-2 \\
                x>n \quad !?!
            \end{cases}
        \end{equation}
        Получили, что количество "уменьшений на 2" (а оно случается лишь тогда, когда элементы мы видим впервые) большем, чем половина исходного массива, то есть как будто мы разбили массив на пары и таких пар оказалось больше половины массива. Противоречие, поэтому такого алгоритма быть не может.
    \end{solution}
        
    \item[9.] Найдите второй максимум в массиве за $n + \lceil \log_2 n \rceil- 2$ сравнение и докажите, что это точная нижняя оценка, то есть меньшего количества сравнений может не хватить.
    \begin{solution}
        Данную задачу можно решить, если при поиске максимального элемента разбивать исходный массив на два подмассива и искать максимум рекурсивно. При этом каждому элементу исходного массива сопоставим массив $contenders$, состоящий из индексов элементов, с которыми он сравнивался на предыдущих шагах. Если сравниваются два элемента $a, b$ и $a > b$, то нужно добавить индекс $b$ в массив претендентов для $a$: $a.contenders.append(index(b))$, а про массив претендентов на второй максимум для $b$ можно забыть, потому что $b$ уже точно не будет максимумом: $delete\, b.contenders$. В итоге, рекурсивно найдя максимум $a^*$ в исходном массиве, мы заимеем массив претендентов на второй максимум $a^*.contenders$, в котором можно уже найти и второй максимум исходного массива. Второй максимум (точнее его индекс) исходного массива будет лежать в $a^*.contenders$, потому что туда попадали только элементы, которые были наибольшими в своих поддеревьях сравнений. Получается, что сначала мы находим первый максимум в исходном массиве за $len(arr)-1$ сравнений, а потом находим максимум в массиве претендентов тоже за $len(arr^*)-1$ сравнений. Длина первого массива $n$, а длина второго массива $\lceil \log_2 n \rceil$, потому что в него падали только те элементы, с которыми сравнивался максимум $a^*$. Суммарно получаем $n + \lceil \log_2 n \rceil - 2$ сравнений для поиска второго максимума в массиве.

        Для поиска максимального элемента в массиве нужно сделать $n-1$ сравнений, которые появляются при рекурсивном поиске максимума (сначала дробим массив на пары и сравниваем в парах, потом победителей делим на пары и сравниваем в парах и так далее, пока не будет два элемента, сравнивающихся между собой). Сравнение задает бинарное отношение над двумя элементами, поэтому, имея дерево сравнений мы можем делать заключения об отношении узлов, а именно, родитель всегда больше всех своих потомков (потому что ищем максимум). Используя эту информацию, можно избежать ненужных сравнений при поиске второго максимума (ведь наивная стратегия -- удалить глобальный максимум из массива и снова найти новый максимум за $(n-1)-1$ сравнений). Эффективнее всего -- это просмотреть все элементы, с которыми сравнивался максимальный (корень дерева сравнений), потому что про них мы знаем, что они меньше максимального, но больше всех тех, с которыми сравнивались они. Ну а из построения бинарного дерева таких претендентов будет как раз $\lceil \log_2 n \rceil$. Среди них максимум ищется за $\lceil \log_2 n \rceil - 1$. Поэтому найти второй максимум в массиве быстрее, чем за $n + \lceil \log_2 n \rceil - 2$ нельзя.
    \end{solution}
\end{enumerate}

\subsection{Демоническое программирование HW7}
\begin{enumerate}
    \item[8.] У профессора есть $k$ яиц и $n$ этажное здание. Он хочет узнать максимальное $x$: если яйцо бросить с $x$-го этажа, оно не разобьётся. Не разбившиеся яйца можно переиспользовать. Минимизировать число бросков в худшем случае.
    \begin{enumerate}
        \item $\O(n^2 k)$.
        \begin{solution}
            Введем матрицу $d$ размером $k$ на $n$. Элемент матрицы $d[i][j]$ -- это минимальное количество бросков яиц для бросков с $j$ этажного здания, если их всего $i$. При таком определении первый столбец матрицы нужно заполнить единицами, потому что, имея 1 этажное здание нам нужен всего один бросок. Первую строку матрицы заполним соответствующими значениями $j$, потому что у нас всего одно яйцо и мы будем проходить последовательно по всем этажам, чтобы найти искомый этаж. Остальные элементы таблицы будем заполнять следующим образом: для всех количеств яиц $i$ с каким-то фиксированным количеством этажей $m$ от 1 до $j$ будем находить максимум бросков яиц для худшего случая относительно этажа $j-m$, где оно не разбивается, и относительно этажа $m-1$, где оно разбивается. Этаж $m$, где яйцо разбивается, делит исходный промежуток $[1; j]$ на 2: $[1; m-1]$ и $[m; j]$. Так как нам необходимо совершить еще один бросок, чтобы проверить этаж, то нужно прибавить единицу:
            \begin{equation}
                d[i][j] = \min(\max(d[i][j-m], d[i-1][m-1])+1).
            \end{equation}
            Ответом будет элемент $d[k][n]$.

            Асимптотика:
            Чтобы найти этаж $m$ нужно $\O(n)$, так как в худшем случае нужно будет пройти все этажи. Для каждого элемента матрицы $d$ нужно находить этот этаж $m$, поэтому суммарная асимптотика будет $\O(kn^2)$.
        \end{solution}
        \item $\O(n k \log{n})$.
        \begin{solution}
            Изменим алгоритм из предыдущего пункта. Введем функцию
            \begin{equation}
                f_1(t) = d[i-1][m-1],
            \end{equation}
            где $t$ -- количество бросков. С увеличением $m$ эта функция не убывает. Введем другую функцию
            \begin{equation}
                f_2(t) = d[i][j-m],
            \end{equation}
            которая не возрастает с увеличением $m$. Теперь элементом $d[i][j]$ будет максимум из этих функций. В таком случае можно воспользоваться бинарным поиском для нахождения $m$: найдем значения функций $f_1, f_2$ относительно текущего $m$, которое мы будем принимать за середину промежутка. Это будет этаж $m$ с минимальным количеством бросков для худшего случая. Если $f_1 < f_2$, то будем двигаться в правую часть промежутка, а в противном случае -- в левую. Далее опять делим отрезов и смотрим на значения функций $f_1, f_2$. В итоге получили промежуток длины 2. Посмотрим на количества бросков для этих этажей, вычислим минимум от максимумов этих двух этажей и внесем результат в таблицу.

            Асимптотика:
            в таком решении $m$ ищется бинарным поиском, поэтому суммарная асимптотика будет $\O(kn\log n)$.
        \end{solution}
        \item $\O(n k)$.
        \begin{solution}
            Изменим смысл столбцов -- пусть теперь они означают количество бросков, поэтому $d[i][j]$ -- правильное количество этажей для $i$ яиц и $j$ бросков в худшем случае. Первые столбец и строчку заполним так же, как в первом пункте, но переход уже будет:
            \begin{equation}
                d[i][j] = d[i-1][j-1]+d[i][j-1]+1
            \end{equation}
            Если при броске яйцо разбивается, то снизу есть $d[i-1][j-1]$ этажей. Если не разбивается, то сверху есть $d[i][j-1]$ этажей. Плюс еще добавляется проверка текущего этажа. Ответом будет минимальное $j^*$, для которого $d[i][j^*]<n$.

            Асимптотика:
            при таком подходе нет проверки, которую мы делали в первом пункте за линию, а во втором за логарифм, поэтому суммарно будет $\O(nk)$.
        \end{solution}
        \item $\O(n \log{n})$.
        \begin{solution}
            Используем решение из предыдущего пункта, но будем использовать бинарный поиск по этажам, а не считать все элементы матрицы.

            Асимптотика:
            благодаря бинарному поиску суммарная асимптотика будет $\O(n\log n)$.
        \end{solution}
    \end{enumerate}
\end{enumerate}

\subsection{Жадные алгоритмы HW9}
\begin{enumerate}
    \item[5.] 
    Будем называть \textit{независимым множеством} (или \textit{антикликой}) подмножество вершин
    графа, в котором нет ребер. Пусть в графе $G$ есть $V$ вершин и $E$ ребер, а максимальная
    степень равна $d$. Найдите в нём независимое множество размера хотя бы:
	\begin{enumerate}
	  \item $\frac{n}{d+1}$ за время $\O(V + E)$
	  \begin{solution}
      Для решения данной задачи заведем массив $visited$, в котором будем отмечать те вершины, которые уже взяты или которые нельзя взять. Дальше итерируемся по вершинам графа: берем первую вершину и отмечаем в $visited$, что уже посетили ее, дальше смотрим соседей первой вершины и тоже отмечаем их. Итерируясь дальше, ищем следующую неотмеченную вершину и повторяем с ней те же шаги. Для всех неотмеченных вершин на текущей итерации мы делаем $deg(v_i)+1$ добавление в $visited$ -- отмечаем вершину и всех ее соседей. Пройдясь по всем вершинам, мы выделим все $n$ вершин:
      \begin{equation}
        \sum_{i \in V^*}(deg(v_i)+1)=n,
      \end{equation}
      где $V^*$ -- независимое множество. Но если количество элементов в антиклике равно $\alpha$, то
      \begin{equation}
        n=\sum_{i \in V^*}(deg(v_i)+1) \le d\cdot\alpha + \alpha \Rightarrow \alpha \ge \frac{n}{d+1}
      \end{equation}
      Таким образом, независимое множество размером хотя бы $\frac{n}{d+1}$ найдено за время $\O(V + E)$, потому что проходим один раз по каждой вершине и каджому ребру.
    \end{solution}
	  \item $\sum\limits_{v\in V(G)} \frac{1}{\deg(v)+1}$ за время $\O(V \log{V} + E)$
	  \begin{solution}
      Для получения такой антиклики можно отсортировать вершины по увеличению  степени вершины и проделать алгоритм из предыдущего пункта только уже в обновленном порядке следования вершин. В таком случае оценка на количество элементов в антиклике изменится следующим образом:
      \begin{equation}
        \alpha\ge\frac{n}{d+1} = \sum\limits_{v\in V(G)} \frac{1}{d+1} \to \sum\limits_{v\in V(G)} \frac{1}{\deg(v)+1}
      \end{equation}
      Так как для каждой вершины выполняется $deg(v_i) \le d$, то количество элементов в антиклике увеличится, потому что знаменатели уменьшатся. В таком случае асимптотика изменится на $\O(V \log{V} + E)$ в связи с сортировкой вершин.
    \end{solution}
	\end{enumerate}
	Считайте, что граф уже дан в памяти в виде массива, где для каждой вершины хранится список её соседей.

%   \item {\bf Пятачок, у тебя есть дома ружье?}\\
% 	Даны $n$ непересекающихся кругов на плоскости. Мы стоим в точке $(0,0)$ и можем стрелять по прямой.
% 	Минимальным числом выстрелов проткнуть все круги.

  \item[7.]
	$n$ школьников упали в яму глубины $S$. Каждый школьник имеет рост (от ног до плеч) $h_i$
	и длину рук $l_i$. Школьники могут вставать друг другу на плечи, верхний школьник может
	вытянуть руки. Чтобы выбраться из ямы необходимо дотянуться руками до уровня земли.
	\begin{enumerate}
		\item Могут ли выбраться все школьники? $\O(n \log n)$.
		\begin{solution}
      Пусть сумма ростов всех школьников это $H$. Рассмотрим $i$-го школьника. Он сможет выбраться, если высота тех, кто под ним плюс его руки будут не меньше глубины ямы:
      \begin{equation}
        H-\sum_{j}h_j + l_i \ge S \Rightarrow l_i+H-S\ge\sum_{j}h_j,
      \end{equation}
      где $j$ -- школьники над школьников $i$. Задача свелась к задаче о дедлайнах, где $d_i=h_i+l_i+H-S$, а $t_i=h_i$. Решая задачу о дедлайнах при таких условиях можно получить информацию, смогут ли выбраться все школьники.
    \end{solution}
		\item Какое максимальное число школьников может выбраться? $\O(n \log n)$.
		\begin{solution}
      Решение предыдущего пункта выдает количество школьников, которые смогут выбраться, а также их индексы. Так как это решение задачи о дедлайнах, то можно утверждать, что решение оптимальное и корректное и выдаст максимальное число школьников, которые смогут выбраться.
    \end{solution}
	\end{enumerate}

%   \item
%     В фирму поступают заказы, которые можно выполнять в произвольном
%     порядке. В каждый момент времени можно работать ровно над одним
%     заказом.  Изначально заказов нет, $i$-й заказ поступает в момент
%     времени $r_i$, работать над ним нужно $t_i$. Пусть $e_i$~-- момент
%     окончания выполнения заказа номер $i$. Распределите работу над
%     заказами так, чтобы минимизировать $\sum_i e_i$. Переходить от
%     одного заказа к другому можно в любой момент времени (даже если
%     заказ не доделан до конца, незаконченный заказ можно будет 
%     возобновить с того же места). 
%     Свойства заказа ($r_i, t_i$) не известны до
%     момента его поступления. Время $\O(n \log n)$, при условии, что
%     всего поступит $n$ заказов.

%   \item
%     \textit{Раскраской вершин} графа $G = (V, E)$ называется функция $c: V \to [m]$, сопоставляющая каждой вершине $G$ цвет от $1$ до $m$. 
%  	Раскраска называется \textit{правильной}, если каждая пара соседних вершин имеет разные цвета. 

%  	Для неориентированного графа $G = (V, E)$ его \textit{хроматическим числом} $\chi(G)$ называется наименьшее возможное число цветов в правильной раскраске $G$.

%  	Для графа $G$ обозначим размер его максимального полного подграфа через $\omega(G)$.

%  	Рассмотрим на вещественной прямой замкнутые отрезки $I_1, I_2, \dots, I_n$. Сопоставим каждому отрезку $I_i$ вершину $v_i$ 
%  	и каждой паре пересекающихся отрезков $(I_i, I_j)$ ребро $(v_i, v_j)$. Такой граф будем называть \textit{интервальным графом}.

%  	Будем называть граф $G$ \textit{совершенным}, если для любого его индуцированного подграфа $H$ верно $\omega(H) = \chi(H)$. 

%  	Докажите, что каждый интервальный граф совершенен. Приведите алгоритм, красящий интервальный граф $G = (V, E)$ с $|V| = n$ в $\omega(H)$ цветов за время $O(n \log(n))$.

%   \item
%  	В фирму поступают заказы, которые можно выполнять в произвольном
%  	порядке. В каждый момент времени можно работать ровно над одним
%  	заказом.  Изначально заказов нет, $i$-й заказ поступает в момент
%  	времени $r_i$, работать над ним нужно $t_i$. 

%  	Все заказы объединены в проекты (один заказ относится к одному
%  	проекту, заказы из одного проекта могут поступать не подряд).

%  	Пусть $e_i$~-- момент окончания выполнения последнего (в порядке
%  	выполнения) из заказов в проекте с номером $i$.

%  	Нужно распределить работу над заказами так, чтобы минимизировать
%  	$\sum_i e_i$. Свойства заказа ($r_i, t_i$, его проект) не известны
%  	до момента его поступления.  Переходить от одного заказа к другому
%  	можно в любой момент времени (даже если заказ не доделан до конца).

%  	Придумайте решение, которое не более чем в два раза хуже
%  	оптимального.  Время $\O(n \log n)$, при условии, что всего поступит $n$ заказов.
\end{enumerate}
    
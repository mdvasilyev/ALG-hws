\section{Сортировки и порядковые статистики}
% \subsection{Практика}
% \begin{enumerate}
%   \item
%     Дана последовательность из $n$ чисел, нужно за один проход и $\O(n)$ времени найти в ней
%     $k$ минимумов, используя $\O(k)$ дополнительной памяти.

%   \item
%     Работает ли аналогичная оценка времени работы детерминированного алгоритма
%     поиска порядковой статистики, если вместо пятерок разбивать элементы на
%     \begin{enumerate}
%       \item семерки.
%       \item тройки.
%     \end{enumerate}

%   \item
%     Придумайте, как добиться от \texttt{QuickSort} времени $\O(n \log{n})$
%     в худшем случае.

%   \item
%     Дан массив из n чисел от 1 до k, разработайте структуру данных, которая за $\O(1)$
%     отвечает на online запросы вида «Сколько в массиве элементов от a до b?». Время на
%     предподсчет $\O(n + k)$.

%   \item
%     Как с помощью цифровой сортировки сортировать строки над константным алфавитом
%     в лексикографическом порядке за $\O(\sum |s_i|)$?

%   \item
%     Даны $n$ точек на плоскости ($x_i, y_i$). Найти точку ($x^{*}, y^{*}$):
%     \begin{enumerate}
%       \item $\max\limits_i \Bigl[ \max(|x_i-x^{*}|, |y_i-y^{*}|) \Bigr] \rightarrow \min$
%       \item $\max\limits_i \Bigl[ |x_i-x^{*}|+|y_i-y^{*}|  \Bigr] \rightarrow \min$
%       \item $\sum\limits_i \Bigl[ (x_i-x^{*})^2+(y_i-y^{*})^2  \Bigr] \rightarrow \min$
%       \item $\sum\limits_i \Bigl[ |x_i-x^{*}|+|y_i-y^{*}| \Bigr] \rightarrow \min$
%       \item $\sum\limits_i \Bigl[ \max(|x_i-x^{*}|, |y_i-y^{*}|) \Bigr] \rightarrow \min$
%     \end{enumerate}

%   \item
% 	Даны два массива из положительных чисел $a$ и $b$, $|a| = |b| = n$.
% 	Выбрать массив $p$ из $k$ различных чисел от $1$ до $n$ так, чтобы
% 	$\frac{\sum_{i=1}^{k}a_{p_i}}{\sum_{i=1}^{k}b_{p_i}} \to \max$. %$\O(n \log{n})$.

% \subsection*{Дополнительные задачи}

%   \item
%     Возьмем массив a из n элементов, каждый из которых — это число $1$ до $n$.
%     Циклический сдвиг номер $i$ -- это последовательность
%     $a_i, a_{i+1}, \dots, a_{n-1}, a_0, a_1, \dots, a_{i-1}$. 
%     \begin{enumerate}
%       \item Предложите алгоритм сортировки циклических сдвигов в лексикографическом
%       порядке за время $O(n^2)$.
%       \item Предложите алгоритм сортировки циклических сдвигов за $\O(n \log n)$.
%     \end{enumerate}

%   \item
%     Пусть мы хотим показать, что некоторая сортирующая сеть сливает два отсортированных
%     массива в один. Покажите, что для этого достаточно показать, что она сливает массивы,
%     состоящие из $0$ и $1$.

% \end{enumerate}

% \pagebreak
\subsection{Домашнее задание}
\begin{enumerate}
  \item
    Есть улица длины $l$, которая освещается $n > 0$ фонарями, $i$-й фонарь находится в
    точке с вещественной координатой $a_i$. Фонарь освещает все точки улицы, которые находятся от него на расстоянии не больше d, где $d$ — некоторое
    положительное число, общее для всех фонарей.
    Найдите минимальное $d$, при котором вся улица освещена. $\O(n)$, $a_i$ не отсортированы.

    \begin{solution}
      На входе имеем массив неотсортированных координат $a_i$. Если каждую координату $a_i$ поделить на $l$, то становится удобно применить блочную сортировку (bucket sort). На лекции доказывали, что
      \begin{equation}
        \mathbb{E}\, T(n) = \O(n).
      \end{equation}
      За линейное время получили отсортированный массив $a_i$. Теперь соображения, которые помогут решить задачу: когда мы будем выбирать конкретное $d$, которое мы хотим минимизировать, мы должны учесть, что оно будет не меньше расстояния от начала улицы до первого фонаря, и оно будет не меньше расстояния от последнего фонаря до конца улицы, и оно будет не меньше половины максимального расстояния между ``внутренними'' фонарями. Половина здесь берется из-за того, что чтобы покрыть территорию между соседними фонарями, достаточно, чтобы каждый из этих фонарей мог покрыть только половину расстояния, тогда в сумме они покроют все расстояние. Так как мы получили отсортированные отнормированные $a_i$, то обозначим их как $a_i'$, а отнормированное $d$ как $d'$, тогда:
      \begin{equation} \label{distances}
        \begin{cases}
          d' \geq a_0' - 0, \\
          d' \geq 1 - a_n', \\
          d' \geq \max(\delta_i) / 2, \quad if n > 1 \Rightarrow \forall i \in [0, n - 1]
        \end{cases}
      \end{equation}
      где $\delta_i$ представляет собой расстояния между соседними фонарями. $\delta_i$ вычисляется через разность между $i+1$-м фонарем и $i$-м фонарем. При этом $i$ пробегает от 0 до $n - 1$. Решим систему неравенств (\ref{distances}) и получим минимальное $d_0'$. Теперь умножим $d_0'$ на $l$, чтобы вернуться к исходным размерам:
      \begin{equation}
        d_0 = d_0' \cdot l.
      \end{equation}
      Это расстояние $d_0$ и будет искомым расстоянием.

      \textit{Корректность}: пусть известен ответ $d_{ans}$. Покажем, что $d_0$, который выдает наш алгоритм, не хуже. Если фонарь только один, то $d_{ans}$ будет равен максимальному из расстояний от начала улицы до фонаря и от фонаря до конца улицы. Наш алгоритм получает точно такой же результат: если $n = 1$, то массив из одного элемента уже отсортирован, следовательно, в системе (\ref{distances}) остаются два первых неравенства. Решая систему неравенств будет выбрано $d_0'$, которое в данном случае будет представлять собой максимальное из расстояний от начала улицы до единственного фонаря и от этого фонаря до конца улицы. $d_0'$ умножается в конце на $l$. Понятно, что так как выбрано максимальное расстояние, оно покроет всю улицу целиком. Теперь, если фонарей $n \neq 1$: $d_{ans}$ будет больше или равен расстояния начала улицы до первого фонаря, а также он будет больше или равен от конца улицы до последнего фонаря, и еще он будет таким, чтобы покрыть расстояние между максимально удаленными соседними фонарями. Наш алгоритм получает точно такой же ответ: сначала алгоритм сортирует $a_i'$, потом подсчитывает $\delta_i$ -- расстояния между всеми соседними фонарями и отбирает максимальное из этих расстояний. После этого алгоритм выбирает минимальное подходящее $d_0'$, которое не меньше, чем расстояние от начала улицы до первого фонаря, и не меньше, чем расстояние от конца улицы до последнего фонаря, и не меньше, чем половина расстояния между максимально удаленными соседними фонарями. $d_0'$ умножается в конце на $l$.

      \textit{Асимптотика}: алгоритм сначала нормирует элементы массива за $\O(n)$, потом сортирует массив с помощью блочной сортировки за $\O(n)$, потом строит $\delta_i$ за $\O(n)$, потом выбирает максимум из $\delta_i$ за $\O(n)$, потом выбирает $d_0'$ за $\O(1)$ и в конце получает $d_0$ за $\O(1)$. В сумме:
      \begin{equation}
        T(n) = \O(n) + \O(n) + \O(n) + \O(n) + \O(1) + \O(1) = \O(n).
      \end{equation}
    \end{solution}

  \item
    Есть массив $a_i$, состоящий из $n$ неотрицательных целых чисел. Найти минимальное натуральное
    число, которого нет в массиве, за $\O(n)$ времени и $\O(1)$ дополнительной памяти.
    Входной массив доступен для записи. \\
    Замечание: $0 \leq a_i < 2^w$, где $w$ -- размер одной ячейки массива в битах.

  \item
    Даны $n$ точек на плоскости ($x_i, y_i$) с весами $w_i \ge 0$. Найти точку ($x^{*}, y^{*}$):
    \begin{enumerate}
      \item \onlygroup{Крыштаповича} $\max\limits_i \Bigl[ \max(|x_i-x^{*}|, |y_i-y^{*}|) \Bigr] \rightarrow \min$
      \item \onlygroup{Крыштаповича} $\max\limits_i \Bigl[ |x_i-x^{*}|+|y_i-y^{*}|  \Bigr] \rightarrow \min$
      \item \onlygroup{Крыштаповича} $\sum\limits_i \Bigl[ (x_i-x^{*})^2+(y_i-y^{*})^2  \Bigr] \rightarrow \min$
      \item $\sum\limits_i \Bigl[ w_i(|x_i-x^{*}|+|y_i-y^{*}|) \Bigr] \rightarrow \min$
      \item $\max\limits_i \Bigl[ w_i(|x_i-x^{*}|+|y_i-y^{*}|) \Bigr] \rightarrow \min$.
    \end{enumerate}

  \item
    В матрице $Q$ из натуральных чисел размера $N \times N$ найти подматрицу размера $H \times W$
    с максимальной медианой. $H, W$ --- нечётные.
    \begin{enumerate}
      \item $\O(N^2 \log{Q_{\max}})$. Здесь $Q_{\max}$ --- максимальный элемент матрицы.
      \item $\O(N^2 \log{N})$.
    \end{enumerate}

% \subsection*{Дополнительные задачи}
%   \item
%     Будем строить сортирующую сеть $M(n,m)$ для слияния двух отсортированных массивов
%     размера n и m следующим образом. Разделим элементы обоих массивов на четные и
%     нечетные, рекурсивно сольем отдельно четные, отдельно нечетные, в конце добавим
%     компараторы для элементов $2k$ и $2k + 1$ (см картинку):
    
%     \includegraphics[width=\textwidth]{source/sorting_network.png}
    
%     \begin{enumerate}
%      \item Покажите, что такая сеть действительно сливает два отсортированных массива.
%          \item Каково будет общее число компараторов в такой сети?
%      \item Какова будет глубина такой сети?
%     \end{enumerate}

\end{enumerate}
\section{Добор баллов}

\subsection{Линейные алгоритмы HW2}
\begin{enumerate}
    
    \item[8.] % https://peltorator.ru/posts/stack-of-records/
        Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{Z}$. За {\bf один проход}
        по последовательности и $\O(n)$ времени найдите для каждого элемента ближайший строго
        меньший слева и ближайший меньший либо равный справа. Кроме самой последовательности
        можно использовать два write-only массива в которые надо записать ответ, один стек
        размера порядка $n$ и $\O(1)$ дополнительной памяти.

    \begin{solution}
        Создадим два массива длины $n$: $l$ и $r$. Элементы $l$ -- индексы ближайших строго меньших элементов, находящихся левее текущего. Элементы $r$ -- индексы ближайших меньших либо равных элементов, находящихся правее текущего. При инициализации заполним оба массива $-1$-ми, которые будут индикаторами того, что у конкретного элемента нет левее (или правее) соседа с меньшим (или меньшим либо равным) значением. Заведем стек, который понадобится для заполнения массивов $l, r$ при проходе по исходному массиву $a$. Алгоритм:

        for i = 0..n-1:
        
        $\>$ $\>$ while !stack.empty() and a[i] <= a[stack.top()]:

        $\>$ $\>$ $\>$ $\>$ r[stack.top()] = i
       
        $\>$ $\>$ $\>$ $\>$ stack.pop()
        
        $\>$ $\>$ if !stack.empty():

        $\>$ $\>$ $\>$ $\>$ l[i] = stack.top()

        $\>$ $\>$ stack.push(i)

        На первой итерации складываем индекс первого элемента в стек, дальше итерируемся по массиву и проверяем меньше либо равен текущий элемент, чем тот, который лежит на вершине стека. Делаем это, пока стек не опустеет либо не будет соблюдаться условие. Если текущий меньше, чем тот, который на вершине стека, то записываем соответствующий индекс в $r$ и снимаем элемент со стека. После этого, если стек непустой, то в $l$ для текущего элемента записываем индекс верхнего элемента стека.

        Корректность:
        Массив $r$ заполняется в том случае, когда текущий элемент меньше либо равен элемента на вершине стека, а элемент на вершине стека -- ближайший к текущему, поэтому $r$ заполняется корректно. Массив $l$ заполняется в том случае, когда текущий элемент строго больше, чем элемент на вершине стека $\rightarrow$ меняем местами и получаем строго меньше, что уже удовлетворяет требованию $l$.

        Асимптотика:
        Цикл по $n$ элементам, на каждой итерации все операции работают за константу. Цикл while, за все $n$ итераций внешнего цикло for, сработает не более $n$ раз. Поэтому в сумме алгоритм работает за $\O(n)$.

    \end{solution}

    \item[9.] % https://e-maxx.ru/algo/maximum_zero_submatrix
        Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
        подпрямоугольник, состоящий только из нулей за $\O(n^2)$.
    
    \begin{solution}
        Пусть исходная матрица задается с помощью $a[i][j]$. Построим матрицу $b[i][j]$, которая изначально заполнена $-1$. $b[i][j]$ -- это индекс ближайшей сверху единицы для $a[i][j]$. $b[i][j]$ можно посчитать, двигаясь по матрице сверху вниз: пусть мы стоит в $i$-ой строке, и известно значение для предыдущей строки. Тогда достаточно скопировать эти значения в $b[i][j]$ для текущей строки, изменив только те элементы, в которых в матрице стоят единицы.

        Искомая нулевая подматрица ограничена со всех сторон единичками или границами. Чтобы определить максимальную нулевую подматрицу будем перебирать номер $i$ нижней строки нулевой подматрицы, затем переберём, в каком столбце $j$ мы будем упирать вверх нулевую подматрицу. Пользуясь значением $b[i][j]$, мы сразу получаем номер верхней строки нулевой подматрицы. Но, чтобы подматрица была максимальной, нужно максимально расширить левую и правую границы. То есть нужно найти такой индекс $k_l$, для которого $b[i][k_l] > b[i][j]$, и при этом $k_l$ ближайший слева для индекса $j$. Тогда $k_l+1$ будет левой границей искомой подматрицы. Для правой границы нужно определить индекс $k_r$ -- ближайший справа от $j$ индекс для которого выполняется условие $b[i][k_r] > b[i][j]$.
        
        Значения $k_l$ и $k_r$ можно записывать в $b[i][j]$ для каждой клетки. Чтобы найти $k_l$ будем просматривать все столбцы $j$ слева направо, и заведём стек, как при решении предыдущей задачи. В стеке будут лежать только те столбцы, в которых значение матрицы $d$ строго больше $d[i][j]$. При переходе от столбца $j$ к следующему нужно обновить содержимое этого стека. Сначала в стек нужно положить столбец $j$, а затем, пока на вершине стека лежит неподходящий элемент, у которого значение $b \le b[i][j+1]$ — доставать этот элемент. $k_r$ ищется аналогично, только столбцы нужно будет просматривать справа налево. В конце пробегаемся по обновленной $b[i][j]$ и для каждой $i$ площадь подматрицы.
        
        Асимптотика:
        Вспомогательную матрицу $b[i][j]$ считаем за $\O(n^2)$. Для каждой строки за линию два раза считаем $k_l$ и $k_r$ (как в предыдущей задаче). Определяем ответ, пробегаясь по матрице за $\O(n^2)$. Суммарно $\O(n^2)$.

    \end{solution}
\end{enumerate}

\subsection{Демоническое программирование HW7}
\begin{enumerate}
    \item[8.] У профессора есть $k$ яиц и $n$ этажное здание. Он хочет узнать максимальное $x$: если яйцо бросить с $x$-го этажа, оно не разобьётся. Не разбившиеся яйца можно переиспользовать. Минимизировать число бросков в худшем случае.
    \begin{enumerate}
        \item $\O(n^2 k)$.
        \begin{solution}
            Введем матрицу $d$ размером $k$ на $n$. Элемент матрицы $d[i][j]$ -- это минимальное количество бросков яиц для бросков с $j$ этажного здания, если их всего $i$. При таком определении первый столбец матрицы нужно заполнить единицами, потому что, имея 1 этажное здание нам нужен всего один бросок. Первую строку матрицы заполним соответствующими значениями $j$, потому что у нас всего одно яйцо и мы будем проходить последовательно по всем этажам, чтобы найти искомый этаж. Остальные элементы таблицы будем заполнять следующим образом: для всех количеств яиц $i$ с каким-то фиксированным количеством этажей $m$ от 1 до $j$ будем находить максимум бросков яиц для худшего случая относительно этажа $j-m$, где оно не разбивается, и относительно этажа $m-1$, где оно разбивается. Этаж $m$, где яйцо разбивается, делит исходный промежуток $[1; j]$ на 2: $[1; m-1]$ и $[m; j]$. Так как нам необходимо совершить еще один бросок, чтобы проверить этаж, то нужно прибавить единицу:
            \begin{equation}
                d[i][j] = \min(\max(d[i][j-m], d[i-1][m-1])+1).
            \end{equation}
            Ответом будет элемент $d[k][n]$.

            Асимптотика:
            Чтобы найти этаж $m$ нужно $\O(n)$, так как в худшем случае нужно будет пройти все этажи. Для каждого элемента матрицы $d$ нужно находить этот этаж $m$, поэтому суммарная асимптотика будет $\O(kn^2)$.
        \end{solution}
        \item $\O(n k \log{n})$.
        \begin{solution}
            Изменим алгоритм из предыдущего пункта. Введем функцию
            \begin{equation}
                f_1(t) = d[i-1][m-1],
            \end{equation}
            где $t$ -- количество бросков. С увеличением $m$ эта функция не убывает. Введем другую функцию
            \begin{equation}
                f_2(t) = d[i][j-m],
            \end{equation}
            которая не возрастает с увеличением $m$. Теперь элементом $d[i][j]$ будет максимум из этих функций. В таком случае можно воспользоваться бинарным поиском для нахождения $m$: найдем значения функций $f_1, f_2$ относительно текущего $m$, которое мы будем принимать за середину промежутка. Это будет этаж $m$ с минимальным количеством бросков для худшего случая. Если $f_1 < f_2$, то будем двигаться в правую часть промежутка, а в противном случае -- в левую. Далее опять делим отрезов и смотрим на значения функций $f_1, f_2$. В итоге получили промежуток длины 2. Посмотрим на количества бросков для этих этажей, вычислим минимум от максимумов этих двух этажей и внесем результат в таблицу.

            Асимптотика:
            в таком решении $m$ ищется бинарным поиском, поэтому суммарная асимптотика будет $\O(kn\log n)$.
        \end{solution}
        \item $\O(n k)$.
        \begin{solution}
            Изменим смысл столбцов -- пусть теперь они означают количество бросков, поэтому $d[i][j]$ -- правильное количество этажей для $i$ яиц и $j$ бросков в худшем случае. Первые столбец и строчку заполним так же, как в первом пункте, но переход уже будет:
            \begin{equation}
                d[i][j] = d[i-1][j-1]+d[i][j-1]+1
            \end{equation}
            Если при броске яйцо разбивается, то снизу есть $d[i-1][j-1]$ этажей. Если не разбивается, то сверху есть $d[i][j-1]$ этажей. Плюс еще добавляется проверка текущего этажа. Ответом будет минимальное $j^*$, для которого $d[i][j^*]<n$.

            Асимптотика:
            при таком подходе нет проверки, которую мы делали в первом пункте за линию, а во втором за логарифм, поэтому суммарно будет $\O(nk)$.
        \end{solution}
        \item $\O(n \log{n})$.
        \begin{solution}
            Используем решение из предыдущего пункта, но будем использовать бинарный поиск по этажам, а не считать все элементы матрицы.

            Асимптотика:
            благодаря бинарному поиску суммарная асимптотика будет $\O(n\log n)$.
        \end{solution}
    \end{enumerate}
\end{enumerate}


    
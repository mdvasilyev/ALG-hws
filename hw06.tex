\section{Сортировки и порядковые статистики}
% \subsection{Практика}
% \begin{enumerate}
%   \item
%     Дана последовательность из $n$ чисел, нужно за один проход и $\O(n)$ времени найти в ней
%     $k$ минимумов, используя $\O(k)$ дополнительной памяти.

%   \item
%     Работает ли аналогичная оценка времени работы детерминированного алгоритма
%     поиска порядковой статистики, если вместо пятерок разбивать элементы на
%     \begin{enumerate}
%       \item семерки.
%       \item тройки.
%     \end{enumerate}

%   \item
%     Придумайте, как добиться от \texttt{QuickSort} времени $\O(n \log{n})$
%     в худшем случае.

%   \item
%     Дан массив из n чисел от 1 до k, разработайте структуру данных, которая за $\O(1)$
%     отвечает на online запросы вида «Сколько в массиве элементов от a до b?». Время на
%     предподсчет $\O(n + k)$.

%   \item
%     Как с помощью цифровой сортировки сортировать строки над константным алфавитом
%     в лексикографическом порядке за $\O(\sum |s_i|)$?

%   \item
%     Даны $n$ точек на плоскости ($x_i, y_i$). Найти точку ($x^{*}, y^{*}$):
%     \begin{enumerate}
%       \item $\max\limits_i \Bigl[ \max(|x_i-x^{*}|, |y_i-y^{*}|) \Bigr] \rightarrow \min$
%       \item $\max\limits_i \Bigl[ |x_i-x^{*}|+|y_i-y^{*}|  \Bigr] \rightarrow \min$
%       \item $\sum\limits_i \Bigl[ (x_i-x^{*})^2+(y_i-y^{*})^2  \Bigr] \rightarrow \min$
%       \item $\sum\limits_i \Bigl[ |x_i-x^{*}|+|y_i-y^{*}| \Bigr] \rightarrow \min$
%       \item $\sum\limits_i \Bigl[ \max(|x_i-x^{*}|, |y_i-y^{*}|) \Bigr] \rightarrow \min$
%     \end{enumerate}

%   \item
% 	Даны два массива из положительных чисел $a$ и $b$, $|a| = |b| = n$.
% 	Выбрать массив $p$ из $k$ различных чисел от $1$ до $n$ так, чтобы
% 	$\frac{\sum_{i=1}^{k}a_{p_i}}{\sum_{i=1}^{k}b_{p_i}} \to \max$. %$\O(n \log{n})$.

% \subsection*{Дополнительные задачи}

%   \item
%     Возьмем массив a из n элементов, каждый из которых — это число $1$ до $n$.
%     Циклический сдвиг номер $i$ -- это последовательность
%     $a_i, a_{i+1}, \dots, a_{n-1}, a_0, a_1, \dots, a_{i-1}$. 
%     \begin{enumerate}
%       \item Предложите алгоритм сортировки циклических сдвигов в лексикографическом
%       порядке за время $O(n^2)$.
%       \item Предложите алгоритм сортировки циклических сдвигов за $\O(n \log n)$.
%     \end{enumerate}

%   \item
%     Пусть мы хотим показать, что некоторая сортирующая сеть сливает два отсортированных
%     массива в один. Покажите, что для этого достаточно показать, что она сливает массивы,
%     состоящие из $0$ и $1$.

% \end{enumerate}

% \pagebreak
\subsection{Домашнее задание}
\begin{enumerate}
  \item
    Есть улица длины $l$, которая освещается $n > 0$ фонарями, $i$-й фонарь находится в
    точке с вещественной координатой $a_i$. Фонарь освещает все точки улицы, которые находятся от него на расстоянии не больше d, где $d$ — некоторое
    положительное число, общее для всех фонарей.
    Найдите минимальное $d$, при котором вся улица освещена. $\O(n)$, $a_i$ не отсортированы.

    \begin{solution}
      На входе имеем массив неотсортированных координат $a_i$. Если каждую координату $a_i$ поделить на $l$, то становится удобно применить блочную сортировку (bucket sort). На лекции доказывали, что
      \begin{equation}
        \mathbb{E}\, T(n) = \O(n).
      \end{equation}
      За линейное время получили отсортированный массив $a_i$. Теперь соображения, которые помогут решить задачу: когда мы будем выбирать конкретное $d$, которое мы хотим минимизировать, мы должны учесть, что оно будет не меньше расстояния от начала улицы до первого фонаря, и оно будет не меньше расстояния от последнего фонаря до конца улицы, и оно будет не меньше половины максимального расстояния между ``внутренними'' фонарями. Половина здесь берется из-за того, что чтобы покрыть территорию между соседними фонарями, достаточно, чтобы каждый из этих фонарей мог покрыть только половину расстояния, тогда в сумме они покроют все расстояние. Так как мы получили отсортированные отнормированные $a_i$, то обозначим их как $a_i'$, а отнормированное $d$ как $d'$, тогда:
      \begin{equation} \label{distances}
        \begin{cases}
          d' \geq a_0' - 0, \\
          d' \geq 1 - a_n', \\
          d' \geq \max(\delta_i) / 2, \quad if n > 1 \Rightarrow \forall i \in [0, n - 1]
        \end{cases}
      \end{equation}
      где $\delta_i$ представляет собой расстояния между соседними фонарями. $\delta_i$ вычисляется через разность между $i+1$-м фонарем и $i$-м фонарем. При этом $i$ пробегает от 0 до $n - 1$. Решим систему неравенств (\ref{distances}) и получим минимальное $d_0'$. Теперь умножим $d_0'$ на $l$, чтобы вернуться к исходным размерам:
      \begin{equation}
        d_0 = d_0' \cdot l.
      \end{equation}
      Это расстояние $d_0$ и будет искомым расстоянием.

      \textit{Корректность}: пусть известен ответ $d_{ans}$. Покажем, что $d_0$, который выдает наш алгоритм, не хуже. Если фонарь только один, то $d_{ans}$ будет равен максимальному из расстояний от начала улицы до фонаря и от фонаря до конца улицы. Наш алгоритм получает точно такой же результат: если $n = 1$, то массив из одного элемента уже отсортирован, следовательно, в системе (\ref{distances}) остаются два первых неравенства. Решая систему неравенств будет выбрано $d_0'$, которое в данном случае будет представлять собой максимальное из расстояний от начала улицы до единственного фонаря и от этого фонаря до конца улицы. $d_0'$ умножается в конце на $l$. Понятно, что так как выбрано максимальное расстояние, оно покроет всю улицу целиком. Теперь, если фонарей $n \neq 1$: $d_{ans}$ будет больше или равен расстояния начала улицы до первого фонаря, а также он будет больше или равен от конца улицы до последнего фонаря, и еще он будет таким, чтобы покрыть расстояние между максимально удаленными соседними фонарями. Наш алгоритм получает точно такой же ответ: сначала алгоритм сортирует $a_i'$, потом подсчитывает $\delta_i$ -- расстояния между всеми соседними фонарями и отбирает максимальное из этих расстояний. После этого алгоритм выбирает минимальное подходящее $d_0'$, которое не меньше, чем расстояние от начала улицы до первого фонаря, и не меньше, чем расстояние от конца улицы до последнего фонаря, и не меньше, чем половина расстояния между максимально удаленными соседними фонарями. $d_0'$ умножается в конце на $l$.

      \textit{Асимптотика}: алгоритм сначала нормирует элементы массива за $\O(n)$, потом сортирует массив с помощью блочной сортировки за $\O(n)$, потом строит $\delta_i$ за $\O(n)$, потом выбирает максимум из $\delta_i$ за $\O(n)$, потом выбирает $d_0'$ за $\O(1)$ и в конце получает $d_0$ за $\O(1)$. В сумме:
      \begin{equation}
        T(n) = \O(n) + \O(n) + \O(n) + \O(n) + \O(1) + \O(1) = \O(n).
      \end{equation}
    \end{solution}

  \item
    Есть массив $a_i$, состоящий из $n$ неотрицательных целых чисел. Найти минимальное натуральное
    число, которого нет в массиве, за $\O(n)$ времени и $\O(1)$ дополнительной памяти.
    Входной массив доступен для записи. \\
    Замечание: $0 \leq a_i < 2^w$, где $w$ -- размер одной ячейки массива в битах.

    \begin{solution}
      Так как $a_i$ -- целые неотрицательные числа, то можно попытаться поработать с ними как с индексами. Будем при проходе расставлять элементы на свои места. Если попалась единица, то она должна стоять на нулевой позиции. Если, например, попалась пятерка, то она должна стоять на четвертой позиции из-за того, что индексы начинаются с нуля. Обозначим $a_i$ как $a[i]$. Тогда хочется, чтобы элемент $a[i]$ стоял на позиции $a[a[i]-1]$. При этом значение элемента (со сдвигом на 1) может быть больше размера массива, поэтому будем расставлять только те элементы, которые могут занять правильную позицию ($a[i] = a[a[i]-1]$). После прохода, на котором были расставлены (насколько возможно) $a[i]$ в правильные позицию, можно совершить еще один проход: начинаем с начала массива, и пока не обнаружим элемент, который не соответствует своей правильной позиции, идем до конца. Если на $i$-ой итерации стоит неправильный элемент ($a[i] \neq i + 1$), то возвращаем $i + 1$ в качестве ответа. Если дошли до конца массива, то возвращаем $n + 1$. Псевдокод, чтобы было понятнее:
      \begin{itemize}
        \item Цикл по $i$ от 0 до размера массива:
        
        \hspace{10mm} Пока $a[i]$ не превосходит размера массива и $a[i]$ не равно $a[a[i]-1]$ повторяем:

        \hspace{20mm} Свап $a[i]$ и $a[a[i]-1]$

        Цикл по $i$ от 0 до размера массива:

        \hspace{10mm} Если $a[i]$ не равно $i + 1$, то возвращаем $i + 1$

        Возвращаем $n + 1$
      \end{itemize}

      Корректность: допустим нам известен ответ, который можно получить следующим образом: отсортируем исходный массив и начнем проходить по нему с начала. Каждый следующий элемент будет превосходить текущий либо на 0, либо на 1, либо больше, чем на 1. Если превосходит на 0 или 1, то идем дальше, если больше, чем на один, то возвращаем текущий элемент, увеличенный на 1. Покажем, что наш алгоритм получает результат не хуже этого. В первом цикле алгоритм расставил все элементы, которые возможно, на ``правильные'' места. Во втором цикле алгоритм нашел позицию первого ``неправильно'' стоящего элемента и потом вычислил минимальное число (добавил 1 к позиции). Видно, что результат не хуже ответа.

      Асимптотика: первый цикл работает за $\O(n)$, потому что, если приходит число, которое превосходит размер массива, то ничего не происходит, и итератор просто увеличивается на 1. Или, если приходит число, которое можно поставить на ``правильное'' место, то происходит свап за $\O(1)$, потом снова проверяется, можно ли поставить очередное число на нужное место. В худшем случае этот внутренний цикл на какой-нибудь итерации проделает $\O(n)$ шагов, но в таком случае на всех остальных итерациях внешнего цикла ничего происходить не будет, поэтому можно сказать, что в сумме будет ($\O(n)+\O(n)=\O(n)$). Второй цикл работает за $\O(n)$ ($n \cdot \O(1)$). В конце возвращение значения за $\O(1)$. В сумме:
      \begin{equation}
        T(n) = \O(n) + \O(n) + \O(1) = \O(n).
      \end{equation}
    \end{solution}

  \item
    Даны $n$ точек на плоскости ($x_i, y_i$) с весами $w_i \ge 0$. Найти точку ($x^{*}, y^{*}$):
    \begin{enumerate}
      \item \onlygroup{Крыштаповича} $\max\limits_i \Bigl[ \max(|x_i-x^{*}|, |y_i-y^{*}|) \Bigr] \rightarrow \min$
      \begin{solution}
        Если рассмотреть одномерную задачу, когда даны $x_i$ с весами $w_i$, то можно понять, что благодаря модулям и разности наша функция отдаленно напоминает параболу. На $\pm \infty$ она уходит в бесконечность, а в диапазоне $x_i$ она принимает какие-то ограниченные значения (если $w_i$ ограничены). Так как функция модуля линейна, все точки (на двумерном графике, где по абсциссе $x_i$, а по ординате $w_i$) будут соединены линиями. Минимум же данной функции будет находиться в точке с наименьшим весом. При этом может возникнуть плато. Наверное, это никак не испортит ситуацию.

        Вернемся к $(x_i, y_i)$. Рассуждения аналогичные одномерной задачи. Находим подходящую точку сначала для $x$, потом для $y$ и получаем $(x^{*}, y^{*})$.
      \end{solution}
      \item \onlygroup{Крыштаповича} $\max\limits_i \Bigl[ |x_i-x^{*}|+|y_i-y^{*}|  \Bigr] \rightarrow \min$
      \item \onlygroup{Крыштаповича} $\sum\limits_i \Bigl[ (x_i-x^{*})^2+(y_i-y^{*})^2  \Bigr] \rightarrow \min$
      \item $\sum\limits_i \Bigl[ w_i(|x_i-x^{*}|+|y_i-y^{*}|) \Bigr] \rightarrow \min$
      \item $\max\limits_i \Bigl[ w_i(|x_i-x^{*}|+|y_i-y^{*}|) \Bigr] \rightarrow \min$.
    \end{enumerate}

  \item
    В матрице $Q$ из натуральных чисел размера $N \times N$ найти подматрицу размера $H \times W$
    с максимальной медианой. $H, W$ --- нечётные.
    \begin{enumerate}
      \item $\O(N^2 \log{Q_{\max}})$. Здесь $Q_{\max}$ --- максимальный элемент матрицы.
      \item $\O(N^2 \log{N})$.
    \end{enumerate}

% \subsection*{Дополнительные задачи}
%   \item
%     Будем строить сортирующую сеть $M(n,m)$ для слияния двух отсортированных массивов
%     размера n и m следующим образом. Разделим элементы обоих массивов на четные и
%     нечетные, рекурсивно сольем отдельно четные, отдельно нечетные, в конце добавим
%     компараторы для элементов $2k$ и $2k + 1$ (см картинку):
    
%     \includegraphics[width=\textwidth]{source/sorting_network.png}
    
%     \begin{enumerate}
%      \item Покажите, что такая сеть действительно сливает два отсортированных массива.
%          \item Каково будет общее число компараторов в такой сети?
%      \item Какова будет глубина такой сети?
%     \end{enumerate}

\end{enumerate}
\section{Интервальные запросы, LCA}

% \subsection{Практика}
% \begin{enumerate}

%   \item
%     Придумайте online static \texttt{RMQ} за
%     \begin{enumerate}
%       \item $\O(n)$ на предподсчет, $\O(\log n)$ на запрос.
%       \item $\O(n \log n)$ на предподсчет, $\O(1)$ на запрос.
%       \item $\O(n \log{\log{n}})$ на предподсчет, $\O(1)$ на запрос.
%       \item $\langle \O(n \log^*n), \O(\log^*n) \rangle$.
%       \item $\pm 1$ \texttt{RMQ} за $\langle \O(n), \O(1) \rangle$.
%     \end{enumerate}

%   \item
% 	Вам дано дерево из одной вершины. Придумайте, как online отвечать на следующие запросы:
% 	\begin{itemize}
% 	  \item Подвесить новую вершину к дереву.
% 	  \item \texttt{LCA} двух вершин.
% 	\end{itemize}
% 	\begin{enumerate}
%       \item $\O(1)$ на подвешивание, $\O(h)$ на \texttt{LCA} ($h$ --- текущая высота).
%       \item $\langle \O(\log{n}) , \O(\log{n}) \rangle$ ($n$ --- число добавлений; считайте, что $n$ известно заранее).
%       \item $\langle \O(1), \O(\log{n}) \rangle$ (используйте скошенный список).
%     \end{enumerate}

%   \item
% 	Дано подвешенное дерево из $n$ вершин с весами на ребрах. Online-запросы:
% 	\begin{enumerate}
% 	  \item сумма весов на пути из $a$ в $b$. $\langle \O(n), \O(1) \rangle$.
% 	  \item минимальный вес на пути из $a$ в $b$. $\langle \O(n \log n), \O(\log n) \rangle$.
% 	\end{enumerate}

%   \item
%     В последовательности длины $n$ из различных целых чисел с помощью дерева отрезков 
%     найдите наибольшую возрастающую подпоследовательность за $\O(n \log n)$.

%   \item
% 	Дан массив из нулей и единиц. Запросы: ``поменять элемент'', ``найти ближайшую слева/справа единицу к позиции $i$''.
% 	$\langle \O(n), \O(\log{n}) \rangle$, online.

%   \item
% 	Дана таблица $n \times n$ с целыми числами. Поступают запросы:
% 	\begin{itemize}
% 	  \item Изменить значение в ячейке $(i, j)$,
% 	  \item Посчитать сумму чисел в прямоугольнике $((l, t), (r, b))$.
% 	\end{itemize}
% 	$\langle \O(n^2 \log n), \O(\log^2 n) \rangle$, online.

%   \item
% 	$k$-инверсией в перестановке $p$ называется набор индексов $i_1 < i_2 < \ldots < i_k$, такой,
% 	что $p[i_1] > p[i_2] > \ldots > p[i_k]$. Найти число $k$-инверсий за $\O(nk\log n)$.

% \subsection*{Дополнительные задачи}

%   \item
% 	Вывести все числа $\ge X$ на отрезке $[L, R]$ массива.
% 	Static online
% 	\begin{enumerate}
% 	    \item $\langle \O(n \log{n}), \O(\log^2 n + k) \rangle$ ($k$ --- размер ответа).
% 	    \item $\langle \O(n \log{n}), \O(\log n + k) \rangle$ 
% 	\end{enumerate}

%   \item
%     Дан массив из $n$ элементов, можно сделать предобработку за $\O(n \log n)$. Запросы: количество
%     различных чисел на отрезке $[L, R]$. \emph{Тут будет подсказка про $prev[i]$.}
%     \begin{enumerate}
%       \item online за $\O(\log^2 n)$.
%       \item offline за $\O(\log n)$.
%       \item online за $\O(\log n)$.
%     \end{enumerate}

%   \item
%     Запросы: $k$-е по порядку среди различных чисел на отрезке $[L, R]$. 
%     \begin{enumerate}
%       \item offline за $\O(\log^3 n)$.
%       \item online за $\O(\log^3 n)$.
%       \item online за $\O(\log^2 n)$.
%     \end{enumerate}

% \end{enumerate}	

% \newpage
\subsection{Домашнее задание}
\begin{enumerate}
	
  \item
	Дано дерево из одной вершины. Требуется уметь отвечать online за $\O(\log n)$ на запросы:
	\begin{itemize}
	  \item подвесить новую вершину $u$ к вершине дерева $v$,
	  \item вернуть диаметр дерева.
	\end{itemize}
	Диаметр дерева --- длина самого длинного простого пути в дереве.
	\begin{solution}
		Для подвешивания (за $\O(1)$) будем использовать список смежности. Также будем хранить глубину текущей вершины и массив родителей (для двоичных подъемов $\rightarrow$ LCA). Диаметр дерева будет состоять из суммы двух самых длинных веток (выходим из одного листа и приходим в другой лист), потому что только таким образом возможно получить наидлиннейший простой путь в дереве. Пусть в какой-то момент времени у нас известно, что диаметр складывается из длин путей $leaf_1\ldots root$ и $root\ldots leaf_2$, а также глубина $leaf_1$ меньше глубины $leaf_2$ (если это не так, то переназываем $leaf_1$ и $leaf_2$, чтобы это выполнялось). Подвешивая новую вершину $u$, запускаем $LCA(leaf_1, u)$ и если ответ $root$, то сравниваем глубину $leaf_1$ и $u$. Если $u$ оказывается глубже, то кладем $leaf_1 \leftarrow u$. Если ответ не $root$, то запускаем $LCA(leaf_2, u)$. Если тут ответ $root$, то сравниваем глубину $leaf_2$ и $u$. Если $u$ оказывается глубже, то кладем $leaf_2 \leftarrow u$. Итого, при каждом добавлении вершины ($\O(1)$) мы переопределяем диаметр дерева с помощью LCA, который работает за $\O(\log n)$. Диаметр переопределяется корректно, потому что мы сравниваем глубины добавляемой вершины и наименее глубокого из листов (говорили в начале, что всегда можно переназвать листья, чтобы сравнивать именно в таком порядке).
	\end{solution}
	
  \item
    Дан ориентированный граф, в котором исходящая степень каждой вершины
	равна единице. Запросы online: из вершины $v$ сделать $k$ шагов вперед и вернуть куда пришли.
	\begin{enumerate}
	  \item Предподсчет: $\O(n \log k_{\max})$, время на запрос: $\O(\log k)$.
	  \begin{solution}
		Для каждой вершины будем хранить массив вершин, которые можно достичь из нее при $k=2^i, i = 0 \ldots \log k_{\max}$. Предподсчет для всех компонент связности тогда займет $\O(n \log k_{\max})$. При ответе на запрос $k$ смотрим на степени двоек, из которых состоит $k$ и идем по графу в соответствии с разложением $k$ на основе предподсчета в порядке уменьшения степени двоек. Как дошли до минимального разряда, возвращаем текущую вершину. Так как идем по степеням двойки, то каждый раз расстояние уменьшается и получается асимптотика $\O(\log k)$ на запрос.
	  \end{solution}
	  \item Предподсчет: $\O(n \log n)$, время на запрос: $\O(\log \min(k, n))$.      
	\end{enumerate}
	
  \item
	Дана скобочная последовательность из круглых скобок длины $n$. Запросы:
	\begin{itemize}
	    \item является ли отрезок $[L, R]$ правильной скобочной последовательностью,
	    \item изменить $i$-ю скобку.
	\end{itemize}
	$\O(n)$ на предподсчет, $\O(\log n)$ на запрос, online.

  \item
	Попробуем модифицировать идею \texttt{SparseTable} так, чтобы она работала для произвольных ассоциативных функций:
	предложите способ выделить $\O(n \log n)$ отрезков в массиве размера $n$ так, что любой
	отрезок $[L, R]$ можно было представить в виде объединения $\O(1)$ непересекающихся выделенных отрезков. 
	Заметим, что дерево отрезков выделяет $\O(n)$ отрезков, и любой отрезок
	представляется как объединение $\O(\log n)$ из них.

  \item
	Дан набор из $m$ отрезков на клетчатой полоске из $n$ клеточек. Сначала в каждой клетке сидит котик.\\
	Запрос: из клетки $i$ ушёл котик, сколько отрезков сейчас не содержат ни одного котика?

    \begin{enumerate}
      \item $\O(n + (k + m)\log{n})$ на $k$ запросов, offline.
      \item $\O(n + k + m)$ на $k$ запросов, offline.
      \item \onlygroup{Мишунина} $\O(1 + (k + m)\log{n})$ на $k$ запросов, online.
    \end{enumerate}

% \subsection*{Дополнительные задачи}

%   \item
%     Придумайте, как в задаче 4 домашнего задания обойтись $\O(n \log{\log{n}})$ отрезков.

\end{enumerate}

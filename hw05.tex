\section{Шустрая сортировка}

% \subsection{Практика}
% \begin{enumerate}

%   \item
%    Даны два массива $a$ и $b$ одинаковой длины. Найти такую перестановку $p$, что 
%     \begin{enumerate}
%       \item $\sum\limits_{i=1}^{n}a_{p_i}b_i \to \max$;
%       \item $\sum\limits_{i=1}^{n}a_{p_i}b_i \to \min$.
%     \end{enumerate}

%   \item
%     Алгоритм работает за $\O(n^2 \log n)$, вероятность успеха $\frac{1}{\log n}$.
%     За какое время можно добиться вероятности успеха $1-\frac{1}{n}$?
%     Подсказка: $(1 - \frac{1}{x})^x \le e^{-1}$ для $x \ge 1$.

%   \item
%     Придумайте вероятностный алгоритм поиска $k$-й порядковой статистики в массиве различных чисел с
%     матожиданием времени работы $\O(n)$.

%   \item
%     Робот Иван Семеныч пробует пирожки. Содержимое пирожков делится на
%     три типа.  Всего пирожков $n$. Каждый пирожок можно попробовать не
%     более одного раза.  Любые два пирожка можно поменять местами.
%     Память у робота маленькая, $\O(\log{n})$ бит.  Помогите Ивану
%     Семенычу отсортировать пирожки по типу: сначала первый, потом
%     второй, потом третий. Сортировка должна работать за линейное
%     время.

%   \item
%     Есть длинный файл из $n$ элементов, его можно последовательно читать, но не хранить целиком.
%     Требуется в конце вывести один из этих $n$ элементов c равной вероятностью. $n$ заранее неизвестно.

%   \item
%     Покажите, что не существует такой {\bf вероятностной} сортировки сравнениями,
%     которая корректно сортирует массив с вероятностью не менее $\frac{1}{2}$ и
%     имеет матожидание времени работы в худшем случае $o(n \log n)$ (считайте, что сравнить пару
%     элементов или сгенерировать 1 случайный бит занимает $\Theta(1)$ времени).

%   \item
%     Дан набор из $n$ пар гаек и болтов, в разных парах размеры гаек и
%     болтов различны. Гайки и болты перемешаны. Требуется для каждой гайки
%     найти соответствующий болт. Сравнивать можно только болты с
%     гайками (сравнить две гайки между собой, или два болта между собой
%     --- невозможно). $\O(n \log{n})$.

%   \item
%     На прямой расположено $n$ точек $p_1$, $p_2$, $\dots$, $p_n$ ($p_i$ в произвольном порядке).
% 	Каждая точка имеет вес $w_i \ge 0$. Требуется найти точку
% 	$q \colon \sum_i \left[ w_i \cdot |p_i - q| \right] \rightarrow \min$. $\O(n)$ в среднем.

%   \item
%     Дана последовательность из $n$ чисел, нужно за один проход и $\O(n)$ времени найти в ней
%     $k$ минимумов, используя $\O(k)$ дополнительной памяти.

%   \item
% 	Пусть в качестве разбивающего элемента всегда берется средний элемент: $\lfloor (l + r) / 2 \rfloor$.\\
% 	Построить массив длины $n$, на котором \texttt{QuickSort} отработает за $\Omega(n^2)$.

% \subsection*{Дополнительные задачи}

%   \item
% 	Даны два массива из положительных чисел $a$ и $b$, $|a| = |b| = n$.
% 	Выбрать массив $p$ из $k$ различных чисел от $1$ до $n$ так, чтобы
% 	$\frac{\sum_{i=1}^{k}a_{p_i}}{\sum_{i=1}^{k}b_{p_i}} \to \max$. $\O(n \log{n})$.

%   \item
%     Пусть мы хотим показать, что некоторая сортирующая сеть сливает два отсортированных
%     массива в один. Покажите, что для этого достаточно показать, что она сливает
%     массивы, состоящие из $0$ и $1$.

% \end{enumerate}

% \pagebreak
\subsection{Домашнее задание}
\begin{enumerate}
 
%   \item
%     Будем называть массив \texttt{a[0..n-1]} \textit{отсортированным на} 90\%, или \textit{почти отсортированным}, если из него можно так вычеркнуть 10\% элементов, чтобы оставшиеся оказались в отсортированном порядке.

%     Попытаемся построить эффективный алгоритм, по входному массиву отличающий два случая:
%     \begin{itemize}
%     	\item массив полностью отсортирован
%     	\item массив \textbf{не} почти отсортирован
%     \end{itemize}

% 	Будем рассматривать только массивы, все элементы которых различны.

%     Рассмотрим следующий алгоритм:
%     % \lstinputlisting{source/check-sort.py}

%     Докажите (и предъявите конкретное значение $k$), что при выборе некоторой
%     константы $k$ данный алгоритм
%     \begin{itemize}
%       \item выдаёт всегда \texttt{True} для отсортированного массива;
%       \item выдает \texttt{False} с вероятностью хотя бы $\frac{2}{3}$,
%         если массив не отсортирован на 90\%.
%     \end{itemize}

%     Подсказка: оцените сверху количество элементов, которые находятся двоичным поиском.

%   \item \onlygroup{Мишунина}
%     Дан набор строчек $s_i$, состоящих из десятичных цифр, суммарной длины $n$.
%     Найдите в каком порядке их нужно сконкатенировать, чтобы получившееся в
%     результате число было максимальным. $\O(n^2 \log{n})$.

  \item[3.]
    Дан массив из $2 \cdot n - 1$ числа, который нельзя
    модифицировать. Есть дополнительная память на $n + 1$ элемент
    массива и ещё $\O(1)$ сверху. Требуется найти медиану за $\O(n \log n)$.
    \begin{solution}
      Для решения поставленной задачи будем использовать две кучи: одна минкуча, вторая макскуча. При проходе по массиву будем следить за тем, чтобы размеры куч либо совпадали либо отличались на один элемент (от этого будет зависеть, в какую кучу будем вставлять следующий элемент), минимальный элемент минкучи (корень) был больше максимального элемента макскучи (тоже корень), а также будем поддерживать следующий инвариант: суммарное число элементов в обеих кучах не превосходит $n+1$. В этой задаче хочется воспользоваться тем соображением, что для определения медианы не нужно обладать информацией обо всех элементах одновременно. Я имею в виду следующую ситуацию: предположим у нас есть уже отсортированный массив; если мы уберем $k$ первых и $k$ последних элементов (понятно, что должно соблюдаться условие $2k\leq n-1$, где $n$ -- длина массива), то медиана не изменится.

      Поэтому предлагаю следующий алгоритм: начинаем проходиться по массиву, поддерживая инвариант: суммарное количество элементов в обеих кучах не превосходит $n+1$ и минимальный элемент минкучи был больше максимального элемента макскучи. Как определять, в какую кучу вставлять элемент: если очередной элемент больше корня макскучи, то вставляем его в минкучу, в противном случае -- в макскучу. В какой-то момент суммарно в обеих кучах оказывается $n+1$ элемент. В этот момент начнем либо отбрасывать приходящие элементы, либо заменять некоторые элементы в кучах на приходящие. Как это сделать: если элемент больше максимального в минкуче, то скипаем его; если элемент меньше максимального в минкуче и больше минимального в минкуче, то удаляем максимальный и вставляем в минкучу текущий; если элемент меньше минимального в макскуче, то скипаем его; если элемент больше минимального в макскуче и меньше максимального в макскуче, то удаляем минимальный и вставляем в макскучу текущий.

      Когда дойдем до конца, нужно будет извлечь медиану: если $n+1$ нечетно и количество элементов в минкуче нечетно, то медиана -- корень минкучи; если $n+1$ нечетно и количество элементов в макскуче нечетно, то медиана -- корень макскучи. Если $n+1$ четно, то медиана -- корень макскучи.

      Корректность: так как мы отбрасывали либо самые минимальные, либо самые максимальные элементы, то в сжатом массиве положение медианы не изменилось. Время: прошлись по всем элементам $n$, на каждом шаге выполняли операции с кучами ($\O(\log n)$), поэтому суммарное время $\O(n\log n)$
    \end{solution}

  \item[4.]
    Даны массив из $n$ чисел и $m$ чисел $p_1, p_2, \dots p_m$, нужно за
    $\O(n \log m + m)$ для каждого $i$ найти $p_i$-ую порядковую статистику.

  \item[5.]
    Дан массив \texttt{A[1..n]} из $n$ различных чисел. Массив не обязательно отсортирован.
    Требуется найти $k$ ближайших к медиане элементов за линейное в среднем время. Решить для двух метрик.
    \begin{enumerate}
      \item По позиции в отсортированном массиве.
         $$d(x, \texttt{median}) = |\texttt{pos}(x) - \texttt{pos}(\texttt{median})|,$$
         где $\texttt{pos}(x)$ --- позиция элемента $x$ в отсортированном массиве.

      \item По значению.
         $$d(x, \texttt{median}) = |x - \texttt{median}|.$$
    \end{enumerate}

  \item[6.] \exceptgroup{Мишунина}
    Докажите, что среднее время работы данного алгоритма равно $\O(n^2 \log k)$, где $k$ -- количество инверсий:
    \begin{verbatim}
      while a is not sorted:
        repeat n times:
            i = random in [0..n)
            j = random in [0..n)
            if a[min(i, j)] > a[max(i, j)]:
                swap(a[i], a[j])
    \end{verbatim}

\end{enumerate}	

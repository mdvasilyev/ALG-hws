\section{Система непересекающихся множеств}

% \subsection{Практика}
% \begin{enumerate}

%   \item
%     Ребра только добавляются, \texttt{online}, после каждого добавления говорить,
%     является ли граф двудольным. $\O(m \log^* n)$.

%   \item
%     В каждой клетке прямой записано число 0 или 1. Поступает информация:
%     четность числа единиц на отрезке $[L_i, R_i]$, найти первый запрос,
%     после которого данные противоречивы. $\O(m \log^* n)$

%   \item
%     Дано корневое дерево из $n$ вершин. Все ребра ориентированы к корню. Путь называется вертикальным,
%     если его вершина-конец является предком вершины-начала. На рёбрах дерева есть веса.
%     Даны $m$ вертикальных путей, за $\O((n + m) \log n)$ времени и $\O(n)$ дополнительной памяти с
%     найти минимум на каждом из путей.

%   \item
%     Пусть при реализации СНМ (классической, на деревьях)
%     использовалось только сжатие путей. Покажите, что время обработки
%     $m$ запросов $get$ можно оценить как $\O((m + n) \log n)$. Подсказка:
%     рассмотрите отдельно легкие и тяжелые ребра. Ребро называется
%     легким, если размер поддерева его нижнего конца меньше, чем половина
%     размера поддерева его верхнего конца, тяжелым --- иначе.

%   \item
%     Дан набор из $n$ корневых деревьев, каждое из одной вершины. Операции online:
%     \begin{itemize}
%       \item подвесить за корень одно из деревьев к другому ребром заданного веса,
%       \item посчитать сумму весов ребер на пути из вершины $a$ в ее предка
%         $b$ (гарантируется, что запросы поступают только про пары вершина-предок).
%     \end{itemize}
%     \begin{enumerate}
%       \item $\O(\log n)$ на операцию.
%       \item $\O(\log^* n)$ на операцию.
%     \end{enumerate}

%   \item
%     Бюрократы ставят печати. В компании есть $n$ бюрократов. Сверху спустили поручение выполнить $m$
%     заданий в заданном порядке. Задания могут быть трех типов.
%     \begin{itemize}
%       \item Назначить $x$ начальником $y$ (гарантируется, что у $y$ до этого начальства не было).
%       \item Поручить $x$ проставить печать на документе $i$, где $i$ -- номер запроса.
%             После этого $x$ передает документ начальнику, тот ставит печать, передает
%             начальнику и т.д. Самый главный начальник ставит печать и скармливает документ шредеру.
%       \item Узнать, ставил ли $x$ печать на документе $i$.
%     \end{itemize}
%     Поскольку все документы порезаны на мелкие кусочки, на вас последняя надежда. Нужно ответить на
%     все запросы за $\O(m \log^*(n))$ offline.

% \subsection*{Дополнительные задачи}
%   \item
%     Докажите, что в СНМ на $n$ вершинах $m$ последовательных запросов выполняются
%     за\\ $\O(m \log^{**} n) + \O(n)$. Подсказка: раньше рассматривались ребра двух
%     типов: крутые ($rank_e > x^{rank_b}$) и обычные. Теперь так же рассмотрим
%     ``очень крутые'' ребра --- ребра, которые были крутыми в процессе сжатия хотя бы $rank_b$ раз.

% \end{enumerate}

% \pagebreak
\subsection{Домашнее задание}
\begin{enumerate}

  \item
    Дан неориентированный граф с весами на вершинах, в котором в начальный момент нет ребер.
    Вершин $V$ штук. Нужно обрабатывать следующие запросы:
    \begin{itemize}
      \item соединить ребром пару вершин.
      \item по вершине узнать размер связной компоненты, которой вершина принадлежит, и самую
            легкую вершину в этой компоненте.
    \end{itemize}
    $\O(\log^* V)$ на запрос в среднем, \texttt{online}.

    \begin{solution}
      Для решения данной задачи будем использовать СНМ с ранговой эвристикой и эвристикой сжатия путей. При построении СНМ в корне будем дополнительно хранить размер связной компоненты и самую легкую вершину в этой компоненте. Изначально у нас $V$ множеств с размером 1 и весом минимальной вершины -- своим весом. Потом по запросу мы от обеих вершин вызываем $find$ для поиска корней, сравниваем минимальные значения и при $union$ складываем размеры и записываем наименьшую вершину.

      Корректность: алгоритм работает корректно, потому что СНМ с двумя эвристиками работает корректно. Сложение размеров корректно, потому что мы соединяем два множества в одно. Минимум поддерживается корректно, потому что мы на каждом $union$ сохраняем минимум из двух минимальных вершин.

      Асимптотика: $find$ и $union$ работают за $\O(\log^* V)$ (из лекции)
    \end{solution}

  \item
    Дан взвешенный неориентированный граф и $m$ запросов вида <<по паре вершин и числу $x$ узнать,
    существует ли между ними путь, проходящий только по ребрам не тяжелее $x$>>.
    $\O(E \log V + m \log m + m \log^* V)$ на все запросы,  \texttt{offline}.

    \begin{solution}
      Для начала построим MST данного графа. Дальше посортируем все запросы по возрастанию $x$ и будем строить СНМ. Изначально все вершины -- отдельные множества, будем проходить только по ребрам MST. Нужно добавлять только те ребра, которые не тяжелее текущего $x$ -- объединение через $union$. После добавления ребер можно сделать два запроса $find$ из обеих вершин и проверить, приводят ли они в один корень. Если приводят, то между ними существует путь, проходящий по ребрам не тяжелее $x$. И так пока не исчерпаются все запросы.

      Корректность: для начала можно избавиться от большого количества неинтересных ребер, построив MST. По построению на каждом шаге мы получаем СНМ и для двух вершин можно проверить, принадлежат ли они одному множеству через $find$. По структуре СНМ можно гарантировать, что если две вершины принадлежат одному множеству, то между ними будет существовать путь.

      Асимптотика: построение MST за $\O(E \log V)$, сортировка запросов за $\O(m \log m)$ и $m$ запросов $find$ и $unite$ за $\O(m \log^* V)$. Суммарно $\O(E \log V + m \log m + m \log^* V)$.
    \end{solution}
	
  % \item \exceptgroup{Крыштаповича}
	% В компании работают бюрократы, один из которых является директором. У каждого бюрократа, кроме директора,
	% есть непосредственный начальник. Приходят запросы:
	% \begin{itemize}
	%   \item Уволить бюрократа $x$. Если у него были подчиненные, то их новым начальником становится
	% 	начальник $x$. Уволить директора нельзя.
	%   \item Принять на работу $x$ и назначить $y$ его непосредственным начальником. Гарантируется,
	%     что $y$ еще работает.
	%   \item Отправить $x$ сообщение. Если $x$ уже уволен, то сообщение переадресовывается сотруднику,
	% 	бывшему в момент увольнения начальником $x$ (процесс повторяется, пока не найдется еще
	% 	работающий сотрудник). В ответ на запрос нужно вывести сотрудника, который прочитает сообщение.
	% \end{itemize}
	% В начальный момент в компании есть один директор. $n$ запросов, \texttt{online}, $\O(\log^* n)$ в среднем.

\end{enumerate}

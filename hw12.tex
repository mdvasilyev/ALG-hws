\section{Добор баллов}

\subsection{Линейные алгоритмы HW2}
\begin{enumerate}
    
    \item[8.] % https://peltorator.ru/posts/stack-of-records/
        Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{Z}$. За {\bf один проход}
        по последовательности и $\O(n)$ времени найдите для каждого элемента ближайший строго
        меньший слева и ближайший меньший либо равный справа. Кроме самой последовательности
        можно использовать два write-only массива в которые надо записать ответ, один стек
        размера порядка $n$ и $\O(1)$ дополнительной памяти.

    \begin{solution}
        Создадим два массива длины $n$: $l$ и $r$. Элементы $l$ -- индексы ближайших строго меньших элементов, находящихся левее текущего. Элементы $r$ -- индексы ближайших меньших либо равных элементов, находящихся правее текущего. При инициализации заполним оба массива $-1$-ми, которые будут индикаторами того, что у конкретного элемента нет левее (или правее) соседа с меньшим (или меньшим либо равным) значением. Заведем стек, который понадобится для заполнения массивов $l, r$ при проходе по исходному массиву $a$. Алгоритм:

        for i = 0..n-1:
        
        $\>$ $\>$ while !stack.empty() and a[i] <= a[stack.top()]:

        $\>$ $\>$ $\>$ $\>$ r[stack.top()] = i
       
        $\>$ $\>$ $\>$ $\>$ stack.pop()
        
        $\>$ $\>$ if !stack.empty():

        $\>$ $\>$ $\>$ $\>$ l[i] = stack.top()

        $\>$ $\>$ stack.push(i)

        На первой итерации складываем индекс первого элемента в стек, дальше итерируемся по массиву и проверяем меньше либо равен текущий элемент, чем тот, который лежит на вершине стека. Делаем это, пока стек не опустеет либо не будет соблюдаться условие. Если текущий меньше, чем тот, который на вершине стека, то записываем соответствующий индекс в $r$ и снимаем элемент со стека. После этого, если стек непустой, то в $l$ для текущего элемента записываем индекс верхнего элемента стека.

        Корректность:
        Массив $r$ заполняется в том случае, когда текущий элемент меньше либо равен элемента на вершине стека, а элемент на вершине стека -- ближайший к текущему, поэтому $r$ заполняется корректно. Массив $l$ заполняется в том случае, когда текущий элемент строго больше, чем элемент на вершине стека $\rightarrow$ меняем местами и получаем строго меньше, что уже удовлетворяет требованию $l$.

        Асимптотика:
        Цикл по $n$ элементам, на каждой итерации все операции работают за константу. Цикл while, за все $n$ итераций внешнего цикло for, сработает не более $n$ раз. Поэтому в сумме алгоритм работает за $\O(n)$.

    \end{solution}

    \item[9.] % https://e-maxx.ru/algo/maximum_zero_submatrix
        Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
        подпрямоугольник, состоящий только из нулей за $\O(n^2)$.
    
    \begin{solution}
        Пусть исходная матрица задается с помощью $a[i][j]$. Построим матрицу $b[i][j]$, которая изначально заполнена $-1$. $b[i][j]$ -- это индекс ближайшей сверху единицы для $a[i][j]$. $b[i][j]$ можно посчитать, двигаясь по матрице сверху вниз: пусть мы стоит в $i$-ой строке, и известно значение для предыдущей строки. Тогда достаточно скопировать эти значения в $b[i][j]$ для текущей строки, изменив только те элементы, в которых в матрице стоят единицы.

        Искомая нулевая подматрица ограничена со всех сторон единичками или границами. Чтобы определить максимальную нулевую подматрицу будем перебирать номер $i$ нижней строки нулевой подматрицы, затем переберём, в каком столбце $j$ мы будем упирать вверх нулевую подматрицу. Пользуясь значением $b[i][j]$, мы сразу получаем номер верхней строки нулевой подматрицы. Но, чтобы подматрица была максимальной, нужно максимально расширить левую и правую границы. То есть нужно найти такой индекс $k_l$, для которого $b[i][k_l] > b[i][j]$, и при этом $k_l$ ближайший слева для индекса $j$. Тогда $k_l+1$ будет левой границей искомой подматрицы. Для правой границы нужно определить индекс $k_r$ -- ближайший справа от $j$ индекс для которого выполняется условие $b[i][k_r] > b[i][j]$.
        
        Значения $k_l$ и $k_r$ можно записывать в $b[i][j]$ для каждой клетки. Чтобы найти $k_l$ будем просматривать все столбцы $j$ слева направо, и заведём стек, как при решении предыдущей задачи. В стеке будут лежать только те столбцы, в которых значение матрицы $d$ строго больше $d[i][j]$. При переходе от столбца $j$ к следующему нужно обновить содержимое этого стека. Сначала в стек нужно положить столбец $j$, а затем, пока на вершине стека лежит неподходящий элемент, у которого значение $b \le b[i][j+1]$ — доставать этот элемент. $k_r$ ищется аналогично, только столбцы нужно будет просматривать справа налево. В конце пробегаемся по обновленной $b[i][j]$ и для каждой $i$ площадь подматрицы.
        
        Асимптотика:
        Вспомогательную матрицу $b[i][j]$ считаем за $\O(n^2)$. Для каждой строки за линию два раза считаем $k_l$ и $k_r$ (как в предыдущей задаче). Определяем ответ, пробегаясь по матрице за $\O(n^2)$. Суммарно $\O(n^2)$.

    \end{solution}
        
\subsection{Разделяй и властвуй HW3}

\end{enumerate}
    
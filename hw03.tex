\section{Разделяй и властвуй}

% \subsection{Практика}

% Пусть $a \ge 1$ и $b > 1$ --- константы, $f(n)$ --- функция, $T(n)$
% определено при неотрицательных $n$ формулой
% $$ T(n) = aT(n/b) + f(n),
% $$ где под $n/b$ понимается либо $\lceil n/b \rceil$, либо $\lfloor
% n/b \rfloor$.  Тогда
% \begin{itemize}
% \item если $f(n) = \O(n^{\log_b{a-\epsilon}})$ для некоторого
%   $\epsilon > 0$, то $T(n) = \Theta(n^{\log_b{a}})$;
% \item если $f(n) = \Theta(n^{\log_b{a}})$, то $T(n) =
%   \Theta(n^{\log_b{a}} \log{n})$;
% \item если $f(n) = \Omega(n^{\log_b{a + \epsilon}})$ для некоторого
%   $\epsilon > 0$ и если $af(n/b) \le cf(n)$ для некоторой константы $c
%   < 1$ и достаточно больших $n$, то $T(n) = \Theta(f(n))$.
% \end{itemize}

% \begin{enumerate}
%   \item
%     Дана монотонно неубывающая функция $[1 \dots n] \rightarrow \{0, 1\}$. Напишите
%     псевдокод, находящий последний $0$ и первую $1$ за $\O(\log n)$ вызовов функции.

%   \item
%     Есть $n$ веревок, каждая имеет целую длину $l_i$, которые можно
%     резать. Нужно получить $k$ одинаковых кусков максимальной
%     целочисленной длины (также могут остаться неиспользованные обрезки).
%     $\O(n \log{l_{ \max }})$.

%   \item
%     Сделайте предподсчет за $\O(n\log n)$, чтобы за $\O(\log n)$
%     online отвечать на запрос ``сколько раз число $x$ встречается на отрезке
%     $[l..r]$''?

%   \item
%     Есть $k$ отсортированных массивов. В сумме массивы содержат $n$
%     элементов. Слить массивы за $\O(n \log k)$.

%    \item
%      Даны два сортированных массива длины $n$, которые нельзя модифицировать. Найдите
%      $k$-ю порядковую статистику в объединении массивов, используя $\O(1)$ дополнительной памяти.
%      \begin{enumerate}
%        \item
%          За $\O(\log n \cdot \log \texttt{MAX})$.
%          Значения элементов по модулю не превышают \texttt{MAX}.
%        \item За $\O(\log n)$.
%      \end{enumerate}

%   \item
%     Даны два отсортированных массива $a$ и $b$ длины $n$, сгенерировать все
%     попарные суммы $a_i + b_j$ в сортированном порядке.
%     \begin{enumerate}
%       \item За $\O(n^2 \log n)$.
%       \item За $\O(n^3)$ с использованием $\O(n)$ дополнительной памяти.
%       \item За $\O(n^3)$ с использованием $\O(1)$ дополнительной памяти.
%     \end{enumerate}

%   \item
%     Инверсией в массиве чисел $a[\ldots]$ называется такая пара индексов $i, j$, что $i < j$, но $a_i > a_j$. Дан массив из $n$ различных элементов. Требуется найти число инверсий за $\O(n \log n)$.

%   \item
%     Найти отрезок с максимальным средним арифметическим длины
%     от $L$ до $R$. $\O(n\log{n})$.

%   \item
%     Определить асимптотику:
%     \begin{enumerate}
%       \item $T(n) = T(\lceil \frac{n}{2} \rceil) + 1$
%       \item $T(n) = 4 \cdot T(\lfloor \frac{n}{2} \rfloor) + n^k$ для $k \in \{1, 2, 3\}$.
%       \item $T(n) = T(a) + T(n - a) + n$ для произвольной константы $a$.
%       \item $T(n) = 2 \cdot T(\lfloor \frac{n}{2} \rfloor + 17) + n$.    	
%       \item $T(n) = T(\alpha \cdot n) + T((1 - \alpha) \cdot n) + n$ для произвольной константы $\alpha \in (0, 1)$.
%       \item $T(n) = 2 \cdot T(\sqrt{n}) + \log n$
%     \end{enumerate}

% \subsection*{Дополнительные задачи}

%   \item
%      В матрице $Q$ из натуральных чисел размера $N \times N$ найти подматрицу размера $H \times W$
%      с максимальной медианой. $H, W$ --- нечётные.
%      \begin{enumerate}
%        \item $\O(N^2 \log{Q_{\max}})$. Здесь $Q_{\max}$ --- максимальный элемент матрицы.
%        \item $\O(N^2 \log{N})$.
%      \end{enumerate}

%   \item
%     Дан массив из $2n$ чисел. Найти минимальное и максимальное за $3n - 2$ сравнения.

%   \item
%     Найти второй максимум в массиве за $n + \O(\log n)$ сравнений.

%   \item
%     Дано множество из $n$ точек на плоскости. Найти пару ближайших точек
%     за $\O(n \log n)$.

%   \item
%     Найти количество \texttt{AVL} деревьев высоты $h$ из $n$ вершин по простому
%     модулю $p$ за $\O(h n^{\log_2 3})$ (\texttt{AVL} дерево --- корневое двоичное
%     дерево, в котором у каждой вершины высоты двух дочерних поддеревьев
%     отличаются не более, чем на $1$).

% \end{enumerate}

% \pagebreak
\subsection{Домашнее задание}
\begin{enumerate}
  \item 
	Определить асимптотику:
	$$T(n) =
	  \begin{cases}
	    1 & n \le 1 \\
	    2 T(\lfloor \log n \rfloor) + 2^{\log^* n} & n > 1
	  \end{cases}
	$$
	Здесь $\log^* n$ --- \href{https://en.wikipedia.org/wiki/Iterated_logarithm}{итерированный логарифм}.
	Все логарифмы двоичные.
	\begin{solution}
		Если $n > 1$, то 
		\begin{eqnarray}
			T(n) = 2 T(\lfloor \log n \rfloor) + 2^{\log^* n} = 2 (2 T(\lfloor \log \log n \rfloor) + 2^{\log^* \log n}) + 2^{\log^* n} = \\
			2^2 \cdot T(\lfloor \log \log n \rfloor) + 2\cdot2^{\log^* n} = 2^3 \cdot T(\lfloor \log \log \log n \rfloor) + 3 \cdot 2^{\log^* n} = \ldots = \\
			2^m \cdot T(\lfloor \log \ldots (m) \ldots \log n \rfloor) + m \cdot 2^{\log^* n} = \ldots
		\end{eqnarray}
		Мы останавливаемся дробить задачи, когда
		\begin{equation}
			\log \ldots (m) \ldots \log n \leq 1.
		\end{equation}
		Для всех довольно адекватных входных данных $n \leq 2^{65536}$ нам достаточно $m=5$ итераций применения двоичного логарифма, чтобы свести задачу размера $n$ к 1, поэтому
		\begin{equation}
			T(n) = 2^5 \cdot 1 + 5 \cdot 2^{\log^* n} \leq 2^5 \cdot 1 + 5 \cdot 6 = \O(1).
		\end{equation}
		Честно говоря, не знаю, насколько валидно вообще такие преобразования делать, но, думаю, можно оставить, например, вот так:
		\begin{equation}
			T(n) = \O(2^{\log \log \log \log \log n}).
		\end{equation}
	\end{solution}

  \item 
	Есть $m$ стойл с координатами $x_1, \ldots, x_m$ и $n$ коров. Расставить коров по стойлам
	(не более одной в стойло) так, чтобы минимальное расстояние между коровами было максимально.
	$\O(m (\log{m} + \log{x_{\max}}))$.
	\begin{solution}
		Имея последовательность стойл $x_1, \ldots, x_m$, отсортируем ее за $\O(m \log m)$, например, сортировкой слиянием. Если $n > m$, то задача смысла не имеет, поэтому будем считать, что $n \leq m$. Чтобы решить задачу будем действовать следующим образом: первую корову поставим в первое стойло, а дальше будем максимизировать минимальное расстояние $\delta$ бинарным поиском.
		
		Если нам дано какое-то фиксированное число $\delta$, то мы можем однозначно сказать, получится ли с таким числом расставить $n$ коров. Мы последовательно идем по оставшемуся массиву и смотрим разницу между текущим положением и положением последней коровы. Если такая разность меньше заданного $\delta$, то идем дальше, иначе запоминаем новое положение последней коровы и увеличиваем счетчик коров. Дойдя до конца, мы можем сказать, подходит $\delta$ или нет. Если количество коров при заданном $\delta$ оказалось меньше заданного в условии $n$, то такое $\delta$ нам не подходит, иначе -- подходит, или, что то же самое, это означает, что мы смогли расставить нужное число коров с заданным $\delta$.

		По сути, алгоритм такой: ставим корову в первое стойло, потом запускаем бинпоиск, который будет нам давать конкретные значения $\delta$. Как описано выше, мы можем решать, подходит нам очередное $\delta$ или нет. Если подходит, то сдвигаем левую границу бинпоиска, иначе -- правую.

		В таком алгоритме мы изначально остортировали массив за $\O(m \log m)$, а потом искали максимальную минимальную $\delta$ за $\O(m \log{x_{\max}})$ (проверяли за линию на логарифмически уменьшающихся подмассивах). Итоговое время работы: $\O(m (\log{m} + \log{x_{\max}}))$.
	\end{solution}

  \item
    Докажите, что для поиска максимума в массиве различных чисел потребуется
	как минимум $n-1$ сравнение.
	\begin{solution}
		Как я понимаю, фраза про минимум сравнений отсылает нас к идеальному случаю. То есть, даже если нам кто-то сказал, что вот этот конкретный массив в каком-то смысле идеальный с точки зрения поиска максимума, то нам все равно потребуется $n - 1$ сравнение, чтобы найти в нем максимум. Мы не знаем, как устроен этот самый массив, поэтому будем идти по нему линейно и запоминать максимальный элемент. Понятно, что идеальный случай -- это уже отсортированный массив. Понятно, что, если мы начинаем с начала (или с конца, все равно минимальное число сравнений не изменится), то нам надо сравнить первый элемент со вторым, понять, что второй больше, его запомнить, сравнить его с третьим и так далее. Всего потребуется непосредственно $n - 1$ сравнение, чтобы определить максимум.
	\end{solution}
	

  \item
	Найти второй максимум в массиве за $n + \O(\log n)$ сравнений.	

  \item
	Структура данных <<файл последовательного доступа>>
	поддерживает следующие операции за $\O(1)$:
	\begin{itemize}
		\item \emph{Read()}: чтение числа из файла на текущей
		позиции и перевод позиции вперёд на 1 элемент (если конец файла не достигнут).
		\item \emph{Write(x)}: запись числа в файл в текущую
		позицию и перевод позиции вперёд на 1 элемент.
		\item \emph{Rewind()}: перевод позиции на начало файла.
	\end{itemize}

	Требуется отсортировать файл за $\O(n \log{n})$ используя
	$\O(1)$ дополнительных ячеек памяти и $\O(1)$ дополнительных файлов.

  % \item \onlygroup{Кравченко}
  %   Инверсией в массиве чисел $a[\ldots]$ называется такая пара индексов $i, j$, что $i < j$, но $a_i > a_j$. Дан массив из $n$ различных элементов. Требуется найти число инверсий за $\O(n \log n)$.

  % \item \onlygroup{Мишунина}
	% Дано $2n - 1$ коробок с чёрными и белыми шарами.  В $i$-ой коробке
	% находится $w_i$ белых и $b_i$ чёрных шаров. Всего в коробках
	% находится $W$ белых и $B$ чёрных шаров. Требуется выбрать $n$
	% коробок таким образом, чтобы суммарное число белых шаров в них
	% было не менее $\frac{W}{2}$, а чёрных не менее
	% $\frac{B}{2}$. Решить за $\O(n \log n)$.

% \subsection*{Дополнительные задачи}

% 	\item 
% 		Дан массив из $2n$ различных чисел. Найдите минимальное и максимальное за $3n - 2$ сравнения и докажите, что это точная нижняя оценка, то есть меньшего количества сравнений может не хватить.
	
% 	\item
% 		Найдите второй максимум в массиве за $n + \lceil \log_2 n \rceil- 2$ сравнение и докажите, что это точная нижняя оценка, то есть меньшего количества сравнений может не хватить.
\end{enumerate}


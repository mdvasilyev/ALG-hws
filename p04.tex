\section{AVL-деревья}

% \subsection{Практика}
% \begin{enumerate}
%   \item
%     Пусть вам даны два AVL-дерева $T_1$ и $T_2$. Придумайте, как построить AVL-дерево $T$,
%     являющееся объединением деревьев $T_1$ и $T_2$ за время:
%     \begin{enumerate}
%       \item $\O(height(T_1)\times size(T_2))$, если $size(T_1) \ge size(T_2)$.
%       \item $\O(size(T_1) + size(T_2))$
%     \end{enumerate}

%   \item
%     Дано двоичное дерево, в котором AVL-свойство выполнено везде, кроме корня.
%     \begin{enumerate}
%       \item Пусть \texttt{root.l.h = root.r.h + 3}. Как восстановить AVL-свойство всюду за $\O(1)$?
%       \item Пусть \texttt{root.l.h = root.r.h + k}. Как восстановить AVL-свойство всюду за $\O(k)$?
%     \end{enumerate}

%   \item
%     Придумайте \texttt{split} для AVL-деревьев за $\O(\log^2 n)$.
    
%   \item
%     Придумайте \texttt{merge} для AVL-деревьев за $\O(\log n)$.

%   \item
%     Докажите, что придуманный \texttt{split} на самом деле работает за $\O(\log n)$.

%   \item
%     Придумайте структуру данных, позволяющую online за $\O(\log n)$ отвечать на следующие запросы:
%     \begin{itemize}
%       \item добавить элемент $x$
%       \item удалить элемент $x$
%       \item найти $i$-ый по порядку элемент
%       \item найти порядок элемента $x$
%     \end{itemize}
% 	% хранить количество элементов в поддереве каждой вершины]

%   \item
%     Запросы online за $\O(\log n)$:
%     \begin{itemize}
%       \item добавить пару $\langle x, y \rangle$
%       \item удалить пару $\langle x, y \rangle$
%       \item посчитать сумму $y$ по всем парам таким, что $l \le x \le r$
%     \end{itemize}
%   	% хранить сумму элементов в поддереве каждой вершины

%   \item
%     Запросы online за $\O(\log n)$:
%     \begin{itemize}
%       \item добавить пару $\langle x, y \rangle$
%       \item посчитать сумму $y$ по всем парам таким, что $l \le x \le r$
%       \item посчитать сумму $x$ по всем парам таким, что $l \le y \le r$
%     \end{itemize}
%   	% два дерева — по ключам x и по ключам y

%   \item
%     Запросы online за $\O(\log n)$:
%     \begin{itemize}
%       \item \texttt{add(i, x)} --- вставить $x$ на позицию $i$, все элементы после него сдвигаются на $1$ вправо
%       \item \texttt{del(i)} --- удалить элемент на позиции $i$, все элементы после него сдвигаются на $1$ влево
%       \item \texttt{sum(l, r)} --- сумма всех $x$, для которых $l \le i \le r$
%       \item \texttt{add(l, r, value)} --- добавить $value$ ко всем $x$, для которых $l \le i \le r$
%     \end{itemize}

% \subsection*{Дополнительные задачи}

%   \item
%     Уменьшите количество дополнительной информации в AVL-дереве до двух бит на вершину.

%   \item
%     Покажите, что любые два корректные дерева поиска, построенные на одном и том же множестве ключей,
%     можно получить друг из друга последовательностью поворотов.
% \end{enumerate}


% \newpage 
\subsection{Домашнее задание}
\begin{enumerate}
  \item
    Покажите, что:
    \begin{enumerate}
      \item Добавление в AVL-дерево требует $\O(1)$ вращений.
      \item Удаление из AVL-дерева требует $\Omega(\log n)$ вращений в худшем случае.
    \end{enumerate}

  \item
    Придумайте, как реализовать структуру данных, поддерживающую следующие операции на последовательности из чисел:
    \begin{itemize}
      \item Вставить число на позицию (если позиция была занята, то она и все правее
        сдвигается вправо на 1),
      \item Обмен местами последовательных пар соседних чисел на заданном отрезке четной длины
             (пример: $[1,2,3,4,5,6], (2,5) \rightarrow [1,3,2,5,4,6]$),
      \item Вывод числа на заданной позиции.
    \end{itemize}
    Время работы --- $\O(\log{n})$ на запрос, online ($n$ --- текущая длина последовательности).

  \item \exceptgroup{Мишунина}
    Придумайте структуру данных на основе AVL дерева, позволяющую online за $\O(\log n)$ отвечать на следующие запросы:
	\begin{itemize}
	  \item \texttt{insert(x, y)} ($0 \le y < 5$)
      \item \texttt{delete(x)}
      \item \texttt{add(l, r, value)} --- добавить по модулю 5 $value$ ко
        всем $y$, для которых $l \le x \le r$
      \item \texttt{sum(l, r)} --- сумма (обычная, не по модулю) всех $y$,
        для которых $l \le x \le r$
    \end{itemize}

  \item
    Пусть в обычное несбалансированное бинарное дерево поиска добавляются различные элементы в порядке $x_1, x_2, \dots, x_n$. 
    Придумайте алгоритм, поддерживающий для каждой вершины её глубину и ссылки на родителя и детей
    и обновляющий эту информацию при добавлении элемента в дерево за $\O(\log n)$.
    
    Пояснение: если делать добавление наивным спуском вниз, на запрос может уйти $\Omega(n)$ времени; требуется обрабатывать запросы быстрее.

  \item \onlygroup{Мишунина}
    Докажите формально, что \texttt{split} \texttt{AVL} дерева работает за $\O(\log{n})$.

  \item
    Придумайте структуру данных на основе \texttt{AVL} дерева, реализующую список с online операциями:
    \begin{itemize}
      \item \texttt{make($x_0, x_1, x_2, \dots x_{n - 1})$} --- создать список со значениями. $\O(n)$.
      \item \texttt{get(list, i)} --- получить $i$-тый элемент списка длины $n$. $\O(\log{n})$.
      \item \texttt{reverse(list)} --- развернуть список. $\O(1)$.
      \item \texttt{splitAt(list, k)} --- разделить список длины $n$ на префикс длины $k$ и оставшийся суффикс. $\O(\log{n})$.
      \item \texttt{concat(list1, list2)} --- сконкатенировать два списка суммарной длины $n$. $\O(\log{n})$.
    \end{itemize}

% \subsection*{Дополнительные задачи}

%   \item 
%     Напишите на каком-нибудь строго типизированном функциональном языке с зависимыми типами (например, \texttt{Agda})
%     реализацию исправления произвольного дисбаланса и добавления в \texttt{AVL} дерево так, чтобы типизацией гарантировался:
%     \begin{enumerate}
%       \item \texttt{AVL}-инвариант.
%       \item \texttt{AVL}-инвариант и порядок на ключах.
%     \end{enumerate}

%   \item
%     Постройте тест, на котором <<недо-\texttt{AVL}-дерево>>, которое делает только малые вращения,
%     делает $\omega(n \log{n})$ операций после $n$ запросов.

%     Формально: изначально дерево пусто, нужно $n$ раз вызвать \texttt{add(root, $x_i$)} для некоторой
%     последовательности $x_i$, что суммарное время работы $\omega(n \log{n})$.

%     Либо докажите, что такого теста нет.

\end{enumerate}
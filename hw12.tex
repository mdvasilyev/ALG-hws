\section{Добор баллов}

\subsection{Линейные алгоритмы HW2}
\begin{enumerate}
    
    \item[8.] % https://peltorator.ru/posts/stack-of-records/
        Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{Z}$. За {\bf один проход}
        по последовательности и $\O(n)$ времени найдите для каждого элемента ближайший строго
        меньший слева и ближайший меньший либо равный справа. Кроме самой последовательности
        можно использовать два write-only массива в которые надо записать ответ, один стек
        размера порядка $n$ и $\O(1)$ дополнительной памяти.

    \begin{solution}
        Создадим два массива длины $n$: $l$ и $r$. Элементы $l$ -- индексы ближайших строго меньших элементов, находящихся левее текущего. Элементы $r$ -- индексы ближайших меньших либо равных элементов, находящихся правее текущего. При инициализации заполним оба массива $-1$-ми, которые будут индикаторами того, что у конкретного элемента нет левее (или правее) соседа с меньшим (или меньшим либо равным) значением. Заведем стек, который понадобится для заполнения массивов $l, r$ при проходе по исходному массиву $a$. Алгоритм:

        for i = 0..n-1:
        
        $\>$ $\>$ while !stack.empty() and a[i] <= a[stack.top()]:

        $\>$ $\>$ $\>$ $\>$ r[stack.top()] = i
       
        $\>$ $\>$ $\>$ $\>$ stack.pop()
        
        $\>$ $\>$ if !stack.empty():

        $\>$ $\>$ $\>$ $\>$ l[i] = stack.top()

        $\>$ $\>$ stack.push(i)

        На первой итерации складываем индекс первого элемента в стек, дальше итерируемся по массиву и проверяем меньше либо равен текущий элемент, чем тот, который лежит на вершине стека. Делаем это, пока стек не опустеет либо не будет соблюдаться условие. Если текущий меньше, чем тот, который на вершине стека, то записываем соответствующий индекс в $r$ и снимаем элемент со стека. После этого, если стек непустой, то в $l$ для текущего элемента записываем индекс верхнего элемента стека.

        Корректность:
        Массив $r$ заполняется в том случае, когда текущий элемент меньше либо равен элемента на вершине стека, а элемент на вершине стека -- ближайший к текущему, поэтому $r$ заполняется корректно. Массив $l$ заполняется в том случае, когда текущий элемент строго больше, чем элемент на вершине стека $\rightarrow$ меняем местами и получаем строго меньше, что уже удовлетворяет требованию $l$.

        Асимптотика:
        Цикл по $n$ элементам, на каждой итерации все операции работают за константу. Цикл while, за все $n$ итераций внешнего цикло for, сработает не более $n$ раз. Поэтому в сумме алгоритм работает за $\O(n)$.

    \end{solution}

    \item[9.]
        Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
        подпрямоугольник, состоящий только из нулей за $\O(n^2)$.
    
    \begin{solution}
        Для решения данной задачи будем использовать СНМ с ранговой эвристикой и эвристикой сжатия путей. При построении СНМ в корне будем дополнительно хранить размер связной компоненты и самую легкую вершину в этой компоненте. Изначально у нас $V$ множеств с размером 1 и весом минимальной вершины -- своим весом. Потом по запросу мы от обеих вершин вызываем $find$ для поиска корней, сравниваем минимальные значения и при $union$ складываем размеры и записываем наименьшую вершину.
        
        Корректность: алгоритм работает корректно, потому что СНМ с двумя эвристиками работает корректно. Сложение размеров корректно, потому что мы соединяем два множества в одно. Минимум поддерживается корректно, потому что мы на каждом $union$ сохраняем минимум из двух минимальных вершин.
        
        Асимптотика: $find$ и $union$ работают за $\O(\log^* V)$ (из лекции)
    \end{solution}
        
\subsection{Разделяй и встаствуй HW3}

\end{enumerate}
    
\section{Линейные алгоритмы}

% \subsection{Практика}
% \begin{enumerate}

%   \item
%     \begin{enumerate}
%       \item
%         Покажите методом потенциалов, что изначально пустая очередь на двух
%         стеках из предыдущей практики выполняет $n$ операций за $\O(n)$ времени.

%       \item
%         Придумайте более эффективный на практике вариант очереди с минимумом на
%         основе пары из обычной очереди и дека.
%     \end{enumerate}

%   \item
%     Дана последовательность, составленная из скобок \texttt{'(', ')', '[', ']', '\{', '\}'}.
%     Последовательность называется правильной, если она порождается грамматикой:
%     $$
%     \begin{array}{ccc}
%         S & \rightarrow & \varepsilon \\
%         S & \rightarrow & (S)S \\
%         S & \rightarrow & [S]S \\
%         S & \rightarrow & \{ S \}S
%     \end{array}
%     $$
%     Например, последовательности \texttt{'([\{\}])'} и \texttt{'()()'} правильные,
%     а \texttt{'[)'} и \texttt{'[(])'} -- нет.

%     Придумайте алгоритм, который проверяет правильность последовательности за $\O(n)$.

%   \item
%     Дан массив целых чисел $a_i$. Придумайте структуру данных,
%     которая бы умела отвечать на online запросы вида ``По данным $l$ и $r$
%     вернуть $\sum_{i = l}^r a_i$'' за $\O(1)$. Значения в массиве не
%     меняются. Разрешается сделать предподсчёт за $\O(n)$.

%   \item
%     Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{Z}$.
%     Найти $l, r$ ($1 \leq l \leq r \leq n$) такие, что сумма $\sum_{i = l}^r a_i$ была бы максимальной.
%     \begin{enumerate}
%       \item $\O(n)$.
%       \item $\O(n)$ за 1 проход с $\O(1)$ дополнительной памяти (2 способа).
%     \end{enumerate}

%   \item
%     Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{N}$ и $S \in \mathbb{N}$.
%     Найти $l, r$ ($1 \leq l \leq r \leq n$) такие, что сумма $\sum_{i = l}^r a_i = S$. $\O(n)$.

%   \item
%     Вам дан массив из $n$ целых чисел из $[1 \dots n]$ и
%     число $k$. Найдите такие $l$ и
%     $r$, что на отрезке $[l, r]$ встречается хотя бы $k$ различных
%     элементов, или сообщите, что такого отрезка нет. Если таких
%     отрезков несколько, выберите тот из них, длина которого
%     минимальна. Время работы $\O(n)$.

%   \item
%     Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{N}$.
%     Для каждого $a_i$ найти самый правый из элементов, которые левее и не
%     больше его. $\O(n)$.

%   \item
%     Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{N}$.
%     Найти $l, r$ ($1 \leq l \leq r \leq n$) такие, что
%     \begin{enumerate}
%       \item значение $(r - l + 1) \min_{i \in [l, r]} a_i$ было бы максимально.
%       \item значение $\left(\sum_{i \in [l, r]} a_i \right) \min_{i \in [l, r]} a_i$ было бы максимально.
%     \end{enumerate}
%     Задачу требуется решить за линейное от $n$ время.

%   \item
%     Дана последовательность $\sigma = \langle a_1, a_2, \cdots, a_m \rangle$,
%     где каждый $a_i \in [n] = \{1,2,\cdots,n\}$. Обозначим частоту
%     появления элемента $x$ через
%     $f_{\sigma}[x] = \left|\{i | a_i = x\}\right|$.
%     Известно, что $\exists x : f_\sigma[x] > \frac{m}{2}$.
%     Требуется найти $x$ за один проход по
%     последовательности, используя $\O(1)$ дополнительной памяти.

% \subsection*{Дополнительные задачи}

%   \item
%     Придумайте очередь на основе $\O(1)$ стеков, у которой все операции работают за
%     {\bf детерминированные} $\O(1)$.

%   \item
%     Дана квадратная матрица из нулей и единиц. Найти наибольший по площади подпрямоугольник, состоящий только из нулей за $\O(n^2)$.

%   \item    
%     Дана строка $s$ из скобок, а также число $k$. Для всех $i$ проверить, что
%     подстрока $s[i..i+k]$ является правильной скобочной последовательностью.~$\O(n)$.
%     Скобки только одного типа.

%   \item
%     Вам поступает последовательность online запросов вычислить неизвестную функцию $F : X \rightarrow \{0, 1\}$,
%     после каждого запроса вам говорят правильно ли вы ответили. У вас есть набор детерминированных функций-оракулов
%     $f_1 \dots f_n : X \rightarrow \{0, 1\}$, решающих задачу с ошибками, про которые вы больше ничего не знаете. Придумайте
%     алгоритм, который делает $\O(\log{n} + m)$ ошибок, где $m$ --- число ошибок, которое делает
%     лучший оракул (подсказка: назначьте оракулам веса).

%   \item
%     Вам дан массив натуральных чисел и число $k$. Требуется найти
%     подотрезок массива такой, что НОК чисел на нем равен $k$ или заявить,
%     что такого нет. Время работы: $\O(n T_{LCM}(k))$, где $T_{LCM}(k)$ ---
%     время подсчета НОК для чисел размера $k$.

% \end{enumerate}


% \pagebreak
\subsection{Домашнее задание}
\begin{enumerate}

  \item
    Дано двоичное число, заданное в виде битового массива $a$ длины $n$ (от младших битов к старшим), к которому
    затем $m$ раз прибавляют единицу простейшим алгоритмом:
    \begin{lstlisting}
      int carry = 1;
      for (int i = 0; carry > 0 && i < n; i++)
      {
        carry += a[i];
        a[i] = carry % 2;
        carry = carry / 2;
      }
    \end{lstlisting}
    Числа выбраны так, что переполнения не происходит. Докажите методом потенциалов, что суммарное время
    работы будет $\O(n + m)$.
    \begin{solution}
      Имеем битовый массив, к которому выполняются $m$ запросов с истинными стоимостями $c_1, c_2, \ldots, c_m$. Заведем множество состояний $\{S_0, S_1, \ldots, S_m\}$ массива после запроса с номером $i$. Введем учетные стоимости
      \begin{equation}
        \tilde{c_i} = c_i + \varphi(S_i) - \varphi(S_{i-1}),
      \end{equation}
      где $\varphi$ -- потенциал, зададим как число единиц в битовом представлении исходного числа:
      \begin{equation}
        \varphi = \sum_{i = 0}^{n - 1} a[i].
      \end{equation}
      Можем сказать, что в самом начале потенциал нулевой, так как в битовом представлении числа 0 все нули. До числа, заданного в условии, можно дойти за конечное число шагов (прибавлений единиц).

      Хочу (но не знаю, как) дойти до следующего:
      \begin{equation}
        \sum_{i = 1}^{m} c_i = \sum_{i = 1}^{m} \tilde{c_i} - \Delta \varphi \leq \sum_{i = 1}^{m} \tilde{c_i} \leq m \cdot \O(f(n)) = \O(n + m).
      \end{equation}
    \end{solution}

  \item
    Вам дан массив из $n$ элементов и
    список из $m$ запросов $add(x, l, r)$: прибавить $x$ к каждому
    элементу на отрезке $[l, r]$. За $\O(n + m)$ выведите массив,
    получающийся из исходного после выполнения заданных запросов.
    \begin{solution}
      Предпосчитаем префиксные суммы за $\O(n)$:
      \begin{equation}
        S_0, S_1, \ldots, S_{n-1}.
      \end{equation}
      Сумма элементов массива из отрезка $[l, r]$ представляет собой разность $S_r - S_{l - 1}$.
    \end{solution}

  \item
    Дано число, представленное $n$ цифрами в $d$-ичной записи без
    ведущих нулей.  Из числа требуется вычеркнуть ровно $k$ цифр так,
    чтобы результат был максимальным. $\O(n)$, $d$ и $k$ --- не константы.
    \begin{solution}
      Предполагается, что мы умеем сравнивать цифры в $d$-ичной системе счисления. Предлагаю следующую реализацию: заведем стек; пройдем по всем цифрам исходного числа -- от старшего разряда к младшему. Если текущий элемент больше верхнего элемента стека, то складываем его на стек, а если меньше либо равен, то достаем верхний элемент из стека и кладем туда текущий. После прохода по всем $n$ цифрам исходного числа в стеке лежат $k'$ элементов.
      \begin{itemize}
        \item Если $k' = k$, то задача решена, нужно вывести исходное число, удаляя из него элементы, сохраненные на стеке.
        \item Если $k' > k$, то нужно удалять элементы из стека, пока количество элементов на стеке не будет равным $k$.
        \item Если $k' < k$, то нужно вычеркнуть $k - k'$ цифр исходного числа с конца.
      \end{itemize}
    \end{solution}
    
  \item \onlygroup{Мишунина}
    Вам дана строка из трёх типов скобок. Найдите самую длинную ее
    подстроку, являющуюся правильной скобочной последовательностью
    (и докажите, что ваш алгоритм корректно работает). $\O(n)$.

  \item
    Дан массив целых чисел длины $n$. Найдите подотрезок длины
    от $L$ до $R$ с максимальной суммой. $\O(n)$.

  % \item \onlygroup{Мишунина}
  %   Дан массив длины $n$ с целыми числами $a_i$, $-n \leq a_i \leq n$.
  %   Найдите подотрезок с максимальной суммой, длины от $L$ до $R$,
  %   содержащий от $A$ до $B$ различных чисел, за $\O(n)$.
    
  % \item \exceptgroup{Мишунина}
  %   Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{N}$.
  %   \begin{enumerate}
  %   	\item За $\O(n)$ для каждого $a_i$ найти самый правый из элементов, которые левее и меньше его.
  %   	\item За $\O(n)$ для каждого $a_i$ найти самый левый из элементов, которые правее и меньше его.
  %   	\item За $\O(n)$ найти $l, r$ ($1 \leq l \leq r \leq n$) такие, что значение $(r - l + 1) \min_{i \in [l, r]} a_i$ было бы максимально.
  %   	\item За $\O(n)$ найти $l, r$ ($1 \leq l \leq r \leq n$) такие, что значение $\left(\sum_{i \in [l, r]} a_i \right) \min_{i \in [l, r]} a_i$ было бы максимально.
  %   \end{enumerate}

% \subsection*{Дополнительные задачи}

%   \item
%     Дана последовательность $a_1, a_2, \cdots, a_n \in \mathbb{Z}$. За {\bf один проход}
%     по последовательности и $\O(n)$ времени найдите для каждого элемента ближайший строго
%     меньший слева и ближайший меньший либо равный справа. Кроме самой последовательности
%     можно использовать два write-only массива в которые надо записать ответ, один стек
%     размера порядка $n$ и $\O(1)$ дополнительной памяти.

%   \item
%     Дана квадратная матрица из нулей и единиц. Найти наибольший по площади
%     подпрямоугольник, состоящий только из нулей за $\O(n^2)$.
    
%   \item
%     Вам поступает последовательность online запросов вычислить неизвестную функцию $F : X \rightarrow \{0, 1\}$,
%     после каждого запроса вам говорят правильно ли вы ответили. У вас есть набор детерминированных функций-оракулов
%     $f_1 \dots f_n : X \rightarrow \{0, 1\}$, решающих задачу с ошибками, про которые вы больше ничего не знаете. Придумайте
%     алгоритм, который делает $\O(\log{n} + m)$ ошибок, где $m$ --- число ошибок, которое делает
%     лучший оракул (подсказка: назначьте оракулам веса).

\end{enumerate}

